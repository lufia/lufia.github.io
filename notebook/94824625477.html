        <!DOCTYPE HTML>
        <html>
            <head>
                <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
                <link rel="stylesheet" type="text/css" href="../style.css"/>
            </head>
            <body>
                
                
                                    <h1>Go on Plan 9ではまったこと</h1>
                    <h2>Go 1.3.1をビルド</h2>

<p>Plan 9(386)にGo 1.3.1をインストールしてみた。
通常どおりsrc/all.rcを実行したのだけれど、
cmd/8cと出力された後にinvalid opcodeエラーで落ちる。
そのため、インストールできない。</p>

<h2>Go 1.3.0をビルド</h2>

<p>1.3.1と同じ。</p>

<p>stack traceをみると、これも1.3.1と同じで、
src/pkg/runtime/asm_386.sのruntime.aeshashbodyで刺さっている。</p>

<p>余談だけれど、AESENCっていう命令があるのね。</p>

<h2>他OSでコンパイルしたバイナリを動かす</h2>

<p>Linuxなど、他のOSでGOOS, GOARCHをPlan 9へ切り替えてビルドしたバイナリを動かしてみた。</p>

<pre><code>$ GOOS=plan9 GOARCH=386 go build -o hello hello.go
</code></pre>

<p>ソースによって異なるけど、invalid opcodeで落ちた。根本的にまずいくさい。</p>

<h2>クラッシュさせるコードを調べた</h2>

<p>invalid opcodeのメッセージは/sys/src/9/pc/trap.c <sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> のexcnameにあるものだと思う。
だとするとCPUによって発生している割り込みなので、
ソースがどうこう言うよりは奇妙な命令を踏み抜いているだけのようにみえる。</p>

<h3>問題のスタックトレース</h3>

<pre><code>cpu% cat hello.go
package main

import "fmt"

func main() {
    fmt.Println("hello")
}
</code></pre>

<p>これをplan9/386用にコンパイルして実行。</p>

<pre><code>cpu% ./hello
sys: trap: invalid opcode pc=0x0003ebab
PC=0x3ebab

goroutine 1 [running, locked to thread]:
math.init·1()
    /Users/lufia/go/src/pkg/math/pow10.go:34 +0x1b fp=0x10231f38 sp=0x10231f34
math.init()
    /Users/lufia/go/src/pkg/math/unsafe.go:21 +0x41 fp=0x10231f3c sp=0x10231f38
reflect.init()
    /Users/lufia/go/src/pkg/reflect/value.go:2718 +0x47 fp=0x10231f5c sp=0x10231f3c
fmt.init()
    /Users/lufia/go/src/pkg/fmt/scan.go:1169 +0x4c fp=0x10231f94 sp=0x10231f5c
main.init()
    /tmp/h.go:7 +0x41 fp=0x10231f98 sp=0x10231f94
runtime.main()
    /Users/lufia/go/src/pkg/runtime/proc.c:272 +0xd5 fp=0x10231fd0 sp=0x10231f98
runtime.goexit()
    /Users/lufia/go/src/pkg/runtime/proc.c:1771 fp=0x10231fd4 sp=0x10231fd0
</code></pre>

<p>src/pkg/math/pow10.go:34は何かというと</p>

<pre><code>func init() {
    pow10tab[0] = 1.0e0  // これが34行目
    pow10tab[1] = 1.0e1
    for i := 2; i &lt; len(pow10tab); i++ {
        m := i / 2
        pow10tab[i] = pow10tab[m] * pow10tab[i-m]
    }
}
</code></pre>

<p>helloバイナリファイルをダンプしてみた。</p>

<pre><code>$ go tool objdump hello | grep pow10.go:34
pow10.go:34 0x3ebab f20f100570e30b00    REPNE MOVSD_XMM 0xbe370(IP), X0
pow10.go:34 0x3ebb3 f20f1105a03a1000    REPNE MOVSD_XMM X0, 0x103aa0(IP)
</code></pre>

<p>PCのアドレスから察するに、</p>

<pre><code>REPNE MOVSD_XMM 0xbe370(IP), X0
</code></pre>

<p>が踏み抜いた様子。</p>

<h3>アセンブリで再現させてみた。</h3>

<pre><code>main·main+0(SB),$16-0
MOVSD   $1.0,X0
RET

TEXT    main·init+0(SB),$16-0
RET
</code></pre>

<p>これをLinuxで実行させると落ちないが、Plan 9(386)では落ちる。</p>

<p>次に、MOVSDが悪いのかX0(XMM0)が悪いのか、どちらなのかを調べるためPlan 9アセンブラ <sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> で
以下のコードをアセンブルしてみた。</p>

<pre><code>TEXT    main+0(SB), 0, $0
MOVSD   $1.0, X0
RET
</code></pre>

<p>このコードは、6aではアセンブルできる。8aの場合はX0がsyntax errorとなる。</p>

<h2>誰がMOVSDを生成しているのか</h2>

<p>build.golang.orgではplan9/386のステータスが正常にもかかわらず動かないことが不思議。
致命的に間違っているのかと考え、invalid opcodeが発生していた行はfloat64型の変数にfloat64な値を代入する行だったので
そこを中心にコード生成処理を読んだ。</p>

<h3>コード生成</h3>

<p>Go配布物の、src/cmd/8g/gsubr.cのfloatmove()が生成部分だと思う。
float64を代入する処理の途中でuse_sseという変数があって、
これによりfloatmove_sse()かfloatmove_387()か分岐する。</p>

<p>floatmove_387()の場合、代入先がメモリかそれ以外かで命令が変わる。
代入先がメモリの場合はAFMOVDP、それ以外ならAFMOVD命令。
floatmove_sse()の場合、メモリかどうかにかかわらずAMOVSD命令が使われる。
推測すると、plan9/386の場合はfloatmove_387()を使うべきだけれど
なぜかfloatmove_sse()のほうが使われてしまってinvalid opcodeになっている様子。</p>

<h3>use_sseとは</h3>

<p>use_sseフラグはsrc/cmd/gc/lex.cで切り替えられている。</p>

<table><thead><tr><th>GOARCH</th>
  <th>GO386</th>
  <th>use_sse</th>
</tr></thead><tbody><tr><td>386</td>
  <td>387</td>
  <td>0</td>
</tr><tr><td>386</td>
  <td>sse2</td>
  <td>1</td>
</tr></tbody></table><p>GO386環境変数ってなんだと思ったけど、<a href="http://golang.org/doc/install/source">Installing Go from source</a>にきちんと書かれていた。</p>

<h3>解決方法</h3>

<p>invalid opcodeを解決するには、上記ドキュメントの通りGO386環境変数に387を指定してあげなければならない。</p>

<pre><code>$ cd $GOROOT/src
$ GOOS=plan9 GOARCH=386 GO386=387 ./make.bash
</code></pre>

<p>これでビルドすればよい。
go buildのときはGO386環境変数はいらない。</p>

<div class="footnotes" role="doc-endnotes">
<hr><ol><li id="fn:1" role="doc-endnote">
<p><a href="http://plan9.bell-labs.com/sources/plan9/sys/src/9/pc/trap.c%C2%A0">http://plan9.bell-labs.com/sources/plan9/sys/src/9/pc/trap.c </a><a href="#fnref:1" class="footnote-backref" role="doc-backlink">↩︎</a></p>
</li>

<li id="fn:2" role="doc-endnote">
<p><a href="http://plan9.bell-labs.com/sys/doc/asm.html%C2%A0">http://plan9.bell-labs.com/sys/doc/asm.html </a><a href="#fnref:2" class="footnote-backref" role="doc-backlink">↩︎</a></p>
</li>

</ol></div>
                
                
                
                
                
                
                                <div id="footer">
                <span id="timestamp"> August 16th, 2014 12:40am </span>
                                                      <span class="tag">plan9</span>
                                      <span class="tag">golang</span>
                                              </div>
            </body>
        </html>

        