---
Title: Plan 9 ANSI/POSIX環境での環境変数
Category:
- Plan 9
Date: 2019-07-07T02:36:41+09:00
URL: https://blog.lufia.org/entry/2019/07/07/023641
EditURL: https://blog.hatena.ne.jp/lufiabb/lufia.hateblo.jp/atom/entry/17680117127214385054
---

Plan 9ネイティブのCライブラリはPOSIXに準拠しておらず、独自の習慣がある。例えば*fopen*や*fclose*などは使わず*open*や*close*システムコールを使う。バッファリングが必要であれば*Biobuf*を使いなさいという態度を取る。Goの標準パッケージに名残が残っているので、知っていれば雰囲気は伝わると思う。((他にも*dial*や*tokenize*など割と多く残っている))

Plan 9の環境変数は**/env**以下にファイルとして提供されていて、プロセス毎に異なる内容が扱える((正確には、*rfork*のオプションに*RFENVG*と*RFCENVG*があって、これらを使って環境変数を子プロセスと共有したり分離したりといった操作をすることになる))。これらの変数は配列もサポートしていて、配列の場合は`\0`で区切られたバイト列として表現される。例えば`home='/usr/lufia'`の場合、**/env/home**には`"/usr/lufia"`と保存されていて、`path=(. /bin)`('.'と'/bin'の配列)の場合**/env/path**の内容は`".\0/bin"`となる。

## ANSI/POSIX環境

Plan 9にはネイティブ環境の他に、Unixツールを移植するためだけにANSI/POSIX環境(APE)も用意されている。このライブラリはネイティブとは分けて、ヘッダは**/sys/include/ape/**に、アーカイブは**/386/lib/ape/**や**/amd64/lib/ape/**などアーキテクチャ毎に置かれている。POSIXでは、*getenv*や*putenv*で設定した環境変数は*environ*配列からも同じ内容が参照できなければならないという制約があり、*environ*配列は`"home=/usr/lufia"`のような`"name=value"`形式の文字列配列と定義されているため、ANSI/POSIX環境では**/env**を使わずメモリ上の配列を操作する方針をとる。だから*getenv*は*environ*配列を検索するだけの関数で、*putenv*は*environ*配列を更新するだけの関数として用意されている。((明らかに動いてなかったので修正した))

他のプロセスへ環境変数を引き渡す時は、単純に*execve*の引数に*environ*配列を渡すだけで良い。*execve*は渡された*environ*配列を使って**/env**を再構築する。APEライブラリを使ったプログラムは、*main*を実行する前に**/env**を*environ*配列へ読み込む。こうするとPlan 9ネイティブなプログラムは**/env**を参照すればよいし、APEライブラリを使って書かれたプログラムでは引き続き*environ*配列として参照できるようになる。これらの処理は以下のソースコードに書かれている。

* **/sys/src/ape/lib/ap/plan9/_envsetup.c**
* **/sys/src/ape/lib/ap/plan9/execve.c**

ただし、Cの文字列は`\0`を文字列の終わりと扱ってしまうため、ネイティブ環境で配列となっている環境変数をそのまま扱うと(1つ目の`\0`で終わってしまって)2つ目以降の要素を扱うことができない。ネイティブ環境の場合は**/env**以下にファイルがあるため、*stat*等でファイルサイズを取れば長さが分かるけれども、*environ*配列はCの文字列になってしまうため、本来の長さを知る手段がない。なので*_envsetup*は`\0`を`0x1`に置き換えていて、*execve*は**/env**へ書き戻す前に`0x1`を`\0`へ戻す実装となっていた。

そういった理由から、Plan 9のANSI/POSIX環境で、*getenv*を使って得た文字列の途中に`0x1`が見つかった場合、その文字列は配列として扱ってあげる必要がある。

### バグ

余談だけどANSI/POSIX環境の*getenv*は*environ*配列の要素を指すポインタを返す。*putenv*は*environ*配列を更新するが、*getenv*が返したポインタがまだ参照されている可能性があるため、以前の値を変更してはいけない。なので何度も*putenv*を呼び出ししていると、以前の値で使っていたメモリは消すことも再利用することもできずそのままリークする。*setenv*も最終的には*putenv*と同じなので、同じようにリークする。

Plan 9ネイティブの*getenv*は*malloc*した値を返すので、使い終わったらユーザ側で適切に*free*しなければならない。
