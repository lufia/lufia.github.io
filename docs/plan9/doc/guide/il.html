<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<script>
document.createElement('article')
document.createElement('aside')
document.createElement('footer')
document.createElement('header')
document.createElement('nav')
document.createElement('section')
</script>
<style>
article, aside, footer, header, nav, section { display: block }
</style>
<title>Plan 9: ILプロトコル</title>
<script src="/lib/jquery.js"></script>
<script src="/lib/decor.js"></script>
<script src="/plan9/lib/complex.js"></script>
<link rel="stylesheet" type="text/css" href="/plan9/lib/u.css">
<meta name="author" content="http://www.hatena.ne.jp/lufiabb/">
</head>
<body>
<header>
		<h1><a href="/plan9/">Plan 9</a></h1>
</header>
<nav>
	<section>
		<h1>メニュー</h1>
		<ul>
		<li><a href="/plan9/doc/inst/">インストール</a></li>
		<li><a href="/plan9/doc/guide/">システムの使い方</a></li>
		<li><a href="/plan9/doc/devel/">プログラミング</a></li>
		<li><a href="/plan9/doc/adm/">システム管理</a></li>
		<li><a href="/plan9/man/">自作ツール集</a></li>
		</ul>
	</section>
</nav>
<article>
	<p>ILの論文をおおよそ意訳でやってみました。
	それと、いろいろコメントやらリンクやらを張っていますが、
	これらは勝手につけたものだったり、未訳だったりです。</p>
	<section>
		<h1>ILプロトコル</h1>
		<p class="revision">2011年6月17日作成</p>
		<p>Plan 9ファイルシステムプロトコル9PのRPCメッセージを転送するため、
		ILと呼ぶ新しいネットワークプロトコルを実装しました。
		これはコネクション型のプロトコルで、
		IPによってカプセル化されたデータグラムを運ぶ軽量なプロトコルです。
		ILは消失したパケットの再送と順序通りの配達を提供しますが、<a href="http://net-juku.org/tcpip/tcpip102.html">フロー制御</a>と暗黙的な再送はしません。</p>
		<p class="note">暗黙的な再送はおそらく、tcpでの<a href="http://www.7key.jp/nw/tcpip/tcp/tcp2.html">再送依頼を受けたらそれ以降を再送</a>するところかな。
		ILはstateで受けたackの次にあるデータしか再送しないです。</p>
		<section>
			<h2>導入</h2>
			<p>Plan 9は、RPCリクエストとレスポンスメッセージに、
			メッセージ区切りがあり、順序保証を要求するプロトコル(9P)を使います。
			標準IPプロトコルのどれも、9Pメッセージの転送に適切ではありません。
			TCPは高いオーバーヘッドがあり、メッセージの区切りがありません。
			UDPは、単純でメッセージ区切りを持つとはいえ、順序保証がありません。
			我々は自分たちのシステムにIP, TCP, UDPを実装していたとき、
			9Pに適したプロトコルを選別しようとしました。
			要求する性質は:</p>
			<ul>
			<li>信頼性のあるデータグラムサービス</li>
			<li>順番通りの配達</li>
			<li>IPネットワーク</li>
			<li>シンプルで高パフォーマンス</li>
			<li>柔軟なタイムアウト</li>
			</ul>
			<p>標準プロトコルには上記を満たすものが無かったので、
			IL(Internet Link)と呼ばれる新しいプロトコルを設計しました。</p>
			<p>ILは軽量な、IPの上位プロトコルです。
			これはコネクション指向で、メッセージの到着順を保証します。
			クライアントサーバ間でRPCメッセージを転送するために設計されたので、
			フロー制御はなく、構造は固有のフロー制約を含みます。</p>
			<div class="note">
				<p>未解決メッセージ用の小さい窓は、多すぎる受信を防ぐ,
				バッファされつつあるところからの;</p>
			</div>
			<p>ウインドウからあふれたメッセージは捨てられ、再送されなければなりません。
			コネクションの確立時に接続の両端でシーケンス番号の初期値を生成するため、
			2wayハンドシェイクを使います; 続くデータメッセージは、
			受信側でバラバラになったメッセージを再並べ替えできるようにするため、
			シーケンス番号をインクリメントします。
			他のプロトコルとは対照的に、ILは暗黙的な再送が無効です。
			これは混雑したネットワークにおいて、
			暗黙的な再送によってより混雑させるのを防ぎます。
			TCPに似て、ILは往復時間によってタイムアウトを決定しますので、
			インターネットとローカルイーサネットのどちらでも上手に動きます。
			ネットワーク速度に適した肯定応答と再送の時間を見積もるために、
			往復時間(RTT; round-trip timer)を使います。</p>
		</section>
		<section>
			<h2>コネクション</h2>
			<p>ILコネクションは接続している端から端へデータストリームを運びます。
			コネクションが維持されている間、
			片側に入ったデータは入れた順に逆側へ送られます。
			図1は、状態(円)とその変遷(弧)で
			コネクションの機能を描いたステートマシンです。
			それぞれの変遷は、水平線の上が変化の原因となったイベントで、
			下には、このときに受信または送信するメッセージを表しています。
			この論文の残りは、このステートマシンについて議論します。</p>
			<p>&lt;図1&gt;, 原文をみてください。</p>
			<div class="note">
				<p>snd(packet)は相手側へpacketを送信する。
				rcv(packet)は受信。</p>
				<p>packetはtype(seq, ack)かな？typeはsyncとかdataとか。</p>
			</div>
			<dl>
			<dt>ackok</dt>
			<dd>any sequence number between id0 and next inclusive</dd>
			<dt>!x</dt>
			<dd>xを除くなんらかの値</dd>
			<dt>-</dt>
			<dd>なんらかの値</dd>
			</dl>
			<p>ILステートマシンには、Closed, Syncer, Syncee,
			Established, Closingという5つの状態があります。
			コネクションは両端のIPアドレスとポート番号によって識別されます。
			アドレスはIPプロトコルヘッダにあり、
			ポート番号は18バイトのILヘッダにあります。
			コネクションごとに固有の変数は:</p>
			<dl>
			<dt>state</dt>
			<dd>Closed, Syncer, Syncee, Established, Closingのどれか</dd>
			<dt>laddr</dt>
			<dd>32bitローカルIPアドレス</dd>
			<dt>lport</dt>
			<dd>16bitローカルILポート番号</dd>
			<dt>raddr</dt>
			<dd>32bitリモートIPアドレス</dd>
			<dt>rport</dt>
			<dd>16bitリモートILポート番号</dd>
			<dt>id0</dt>
			<dd>32bitシーケンス番号(ローカル側)</dd>
			<dt>rid0</dt>
			<dd>32bitシーケンス番号(リモート側)</dd>
			<dt>next</dt>
			<dd>ローカル側から送られる次のシーケンス番号</dd>
			<dt>rcvd</dt>
			<dd>正常に受信した最後のリモート側番号</dd>
			<dt>unacked</dt>
			<dd>まだACKを受け取っていない最初のシーケンス番号(ローカル側)</dd>
			</dl>
			<p>接続は最初、未割当アドレスでClosedになっています。
			まだ接続されていないコネクションへメッセージが届くか、
			またはユーザが明確に接続すると、コネクションをオープンします。
			最初の場合、メッセージの送信元アドレスとポートがリモート側のそれになり、
			送信先はローカル側として処理します。
			このとき、コネクションの状態はSynceeです。2つ目の場合は、
			ユーザがローカルとリモート両方のアドレスとポートを明示します。
			コネクションの状態はSyncerになり、
			syncメッセージがリモート側に送られます。
			ローカルアドレスの正当な値はIPの実装によります。</p>
		</section>
		<section>
			<h2>シーケンス番号</h2>
			<p>ILはデータメッセージを運びます。
			各メッセージはOSからのwrite命令1回分に対応し、
			それは32bitシーケンス番号により識別されます。
			コネクション両側の初期シーケンス番号はランダムで、
			最初のsyncメッセージで伝えます。
			番号は、続くデータメッセージごとにインクリメントされます。
			再送されたメッセージのシーケンス番号は、最初に送った番号です。</p>
		</section>
		<section>
			<h2>送信/再送</h2>
			<div class="note">
				<dl>
				<dt>acknowledgement</dt>
				<dd>受信確認</dd>
				<dt>acknowledge</dt>
				<dd>承認</dd>
				</dl>
			</div>
			<p>各メッセージは識別子(ID)と受信確認(ACK)という
			2つのシーケンス番号を持ちます。ACKは、
			リモート側で順序正しく受信を確認したシーケンス番号の最大値です。
			dataとdataqueryメッセージの場合、IDはそのシーケンス番号です。
			sync, ack, query, state, closeといったコントロールメッセージでは、
			IDは送ったデータメッセージの最大シーケンス番号より1大きい。</p>
			<div class="note">
				<p>よく分かっていないけど、
				data(201, -)で送った後にsync, ackと続く場合、
				どちらもIDは202になるということなのかな。
				で、その後に送られるdataもIDは202ですが、
				おそらくここでインクリメント。次からIDは203になる。</p>
				<p>ソースを読むと、ilackq関数でunackedに追加するのですが、
				これはilkick関数(データの送信)からしか呼び出していないので
				たぶんあってる。nextを増やしているのもilkickだけだし、
				コントロールメッセージは受信したらすぐ応答しているし。</p>
			</div>
			<p>送信者はデータメッセージをdata型として送ります。
			ACKが返送メッセージに含まれています。
			データを受信してから200msec以内に返送していない場合、
			ackメッセージが送られるでしょう。</p>
			<p>IPでは、順序が入れ違ったり、混雑により消失したり、
			失敗したりするかもしれません。これを克服し、かつネットワークを
			混雑させないために、ILは改良した<a href="http://otsubo.info/contents/network/network06.html">go back nプロトコル</a>を使います。
			平均RTT(round trip time)は、メッセージの送信と
			そのACKを受け取った遅延を計測することによって保たれます。
			いちども承認を受信していなければ、平均RTTを100msecだと仮定します。
			受信確認がまだされていないメッセージでいちばん古いものについて、
			RTTを4回過ぎても受信確認がない場合(図1ではrexmit timeout)は、
			ILはメッセージか受信確認のどちらかが消失したと判断します。
			このとき、送信者は最初の未承認メッセージだけをdataquery型で再送します。
			受信者はdataqueryを受信すると、順番に受信したデータメッセージの
			最大ACKをstateメッセージで応答します。
			これはたぶん、再送されたメッセージのシーケンス番号、または
			(受信者が今までにため込んでいるメッセージの順序が狂ったなら)
			より大きい正常に受信したシーケンス番号でしょう。
			受信者が、順序が狂ったメッセージを保存するかどうかは実装によります。
			我々の実装では前方向に10パケットため込みます。
			送信者はstateメッセージを受信したとき、
			すぐに次の未承認なメッセージをdataquery型で再送します。
			これは全てのメッセージが承認されるまで続けられます。</p>
			<div class="note">
				<dl>
				<dt>sync</dt>
				<dd>最初の2wayハンドシェイク</dd>
				<dt>data</dt>
				<dd>ふつうのデータパケット</dd>
				<dt>dataquery</dt>
				<dd>ひとつのシーケンス番号だけ再送要求</dd>
				<dd>stateを返す</dd>
				<dt>ack</dt>
				<dd>ack</dd>
				<dt>query</dt>
				<dd>データを持たないdataquery</dd>
				<dt>state</dt>
				<dd>正常受信した最大シーケンス番号パケット</dd>
				<dd>未承認パケットがあればdataqueryを返す</dd>
				<dt>close</dt>
				<dd>close</dd>
				</dl>
			</div>
			<p>もし、dataqueryの後にACKが届かないなら、
			タイムアウトの後、送信者はdataqueryメッセージの再送を続けます。
			再送の間隔は指数関数的に増大します。
			最後に受信してから300秒経過した後(図1のdeath timeout)、
			送信者はあきらめて接続が切れたと判断します。</p>
			<p>再送は、Syncer, Syncee, Close状態でも起こります。
			その再送間隔はデータメッセージと同等です。</p>
		</section>
		<section>
			<h2>Keep Alive</h2>
			<p>切れた接続は発見され、リソースを消費しないように取り壊さなければなりません。
			生きているシステムだとしても、これ以上データも受信確認も送らないなら、
			今までに述べたプロトコルは、これらの接続を発見しません。</p>
			<div class="note">
				<p>このあたり翻訳があやしい。</p>
			</div>
			<p>したがって、Established状態において、最後に送信してから6秒間、
			他にメッセージが無いなら、queryを送ります。
			受信者はいつでも、stateメッセージでqueryに応答します。
			もし最後に受信してから30秒間メッセージが届かなければ、
			接続は閉じられます。これは図1に描かれていません。</p>
		</section>
		<section>
			<h2>バイトオーダー</h2>
			<p>すべての32bitと16bit数は<a href="http://www.atmarkit.co.jp/icd/root/72/116970472.html">ネットワークバイトオーダー</a>です。</p>
		</section>
		<section>
			<h2>フォーマット</h2>
			<p>以下は、IPオプションを無いものとして、
			C言語で記述したIP+ILヘッダです。</p>
			<pre>typedef unsigned char byte;
struct IPIL
{
	byte vihl;	/* バージョンとヘッダ長 */
	byte tos;	/* type of service */
	byte length[2];	/* パケット長 */
	byte id[2];	/* Identification */
	byte frag[2];	/* フラグメント情報 */
	byte ttl;	/* Time to live */
	byte proto;	/* プロトコル */
	byte cksum[2];	/* ヘッダのチェックサム */
	byte src[4];	/* IP送信元 */
	byte dst[4];	/* IP送信先 */
	byte ilsum[2];	/* ヘッダを含めたチェックサム */
	byte illen[2];	/* パケット長 */
	byte iltype;	/* パケットタイプ */
	byte ilspec;	/* special */
	byte ilsrc[2];	/* 送信元ポート番号 */
	byte ildst[2];	/* 送信先ポート番号 */
	byte ilid[4];	/* シーケンス番号 */
	byte ilack[4];	/* ACK */
};</pre>
			<p>データはヘッダのすぐ下です。
			ilspecは将来のために予約されているフィールドです。</p>
			<p>チェックサムはilsumとilspecを0にしたうえで計算されます。
			これは標準IPチェックサムで、
			that is, the 16-bit one's complement of the one's complement sum of
			all 16 bit words in the header and text.
			もしメッセージのヘッダとテキストのバイト数が奇数なら、
			上位バイトを0で詰めた16bit数として扱います。</p>
			<p>チェックサムはcksumからデータの終わりまでをカバーします。</p>
			<p>有効なiltype値は:</p>
			<pre>enum {
	sync=		0,
	data=		1,
	dataquery=	2,
	ack=		3,
	query=		4,
	state=		5,
	close=		6,
};</pre>
			<p>illenフィールドはILヘッダとデータのバイト数です。</p>
		</section>
		<section>
			<h2>Numbers</h2>
			<p>IL用のIPプロトコル番号は40。
			割り当てられたILポート番号:</p>
			<dl>
			<dt>7</dt>
			<dd>echo all input to output</dd>
			<dt>9</dt>
			<dd>discard input</dd>
			<dt>19</dt>
			<dd>send a standard pattern to output</dd>
			<dt>565</dt>
			<dd>send IP addresses of caller and callee to output</dd>
			<dt>566</dt>
			<dd>Plan 9認証プロトコル</dd>
			<dt>17005</dt>
			<dd>Plan 9 CPUサービス, データ</dd>
			<dt>17006</dt>
			<dd>Plan 9 CPUサービス, notes(シグナルのようなもの)</dd>
			<dt>17007</dt>
			<dd>Plan 9 exported file systems</dd>
			<dt>17008</dt>
			<dd>Plan 9ファイルサービス</dd>
			<dt>17009</dt>
			<dd>Plan 9 remote execution</dd>
			<dt>17030</dt>
			<dd>Alef Name Server</dd>
			</dl>
		</section>
		<section>
			<h2>参照</h2>
			<ul>
			<li>The Use of Name Spaces in Plan 9</li>
			<li>RFC791, Internet Protocol</li>
			<li>RFC793, Transmission Control Protocol</li>
			<li>RFC768, RFC768, User Datagram Protocol</li>
			</ul>
		</section>
	</section>
</article>
<aside>
	<section>
		<h1>関連情報</h1>
		<ul>
		<li><a href="http://plan9.bell-labs.com/sys/doc/il/il.pdf">原文(PDF)</a></li>
		<li><a href="../../../notes/2011/0618.html">il.cを読む</a></li>
		<li><a href="../inst/il.html">カーネルにilを組み込む</a></li>
		</ul>
	</section>
</aside>
<footer>
	<p>見れない、表示がおかしい場合は、動作環境を添えて<a href="mailto:webmaster@lufia.org">webmaster@lufia.org</a>まで連絡ください。</p>
</footer>
</body>
</html>
