<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>orange/note: fsバックアップメモ</title><meta name="viewport" content="width=device-width,initial-scale=1"/><meta name="author" content="http://www.hatena.ne.jp/lufiabb/"/><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/1b15737708df434c.css" as="style"/><link rel="stylesheet" href="/_next/static/css/1b15737708df434c.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-59c5c889f52620d6.js" defer=""></script><script src="/_next/static/chunks/framework-c2e8b39087850489.js" defer=""></script><script src="/_next/static/chunks/main-7715c9ce3e92f40f.js" defer=""></script><script src="/_next/static/chunks/pages/_app-8e84d751e7e95936.js" defer=""></script><script src="/_next/static/chunks/245-02c6405e66663b10.js" defer=""></script><script src="/_next/static/chunks/pages/%5B%5B...slug%5D%5D-663c09fbf665935a.js" defer=""></script><script src="/_next/static/uudkrhSA2meQW-38gm1fk/_buildManifest.js" defer=""></script><script src="/_next/static/uudkrhSA2meQW-38gm1fk/_ssgManifest.js" defer=""></script></head><body><div id="__next">
<nav>
	<h1>メニュー</h1>
	<ul>
	<li><a href="/notes/index.html"><a>orange/note</a></a></li>
	<li><a href="/notes/pc.html"><a>PC関連</a></a></li>
	<li><a href="/notes/web.html"><a>web製作</a></a></li>
	<li><a href="/notes/sec.html"><a>セキュリティ</a></a></li>
	<li><a href="/notes/hobby.html"><a>本・ゲーム</a></a></li>
	<li><a href="/notes/junk.html"><a>ジャンク</a></a></li>
	</ul>
</nav>
<main>
	<p class="revision">2010年7月5日作成</p>
	<section>
		<h1>fsバックアップメモ</h1>
		<p>ふと気になったので調べてみました。
		今までよく無事だったなあ。。
		単語としては、以下のとおり。</p>
		<dl>
		<div>
			<dt>Cache-WORM</dt>
			<dd>キャッシュとWORMのセットになったディスク</dd>
		</div>
		<div>
			<dt>Cache</dt>
			<dd>Cache-WORMディスクのCache部分</dd>
		</div>
		<div>
			<dt>WORM</dt>
			<dd>Cache-WORMディスクのWORM部分</dd>
		</div>
		</dl>
		<section>
			<h2>Cacheが壊れたとき</h2>
			<p>たぶん、filsysを再設定して、recover mainで復旧。
			とりあえずディスクタイプを先にまとめ。</p>
			<pre><code>dev-&gt;type:
	&#x27;(&#x27; =&gt; Devcat
	&#x27;[&#x27; =&gt; Devmlev
	&#x27;{&#x27; =&gt; Devmirr
	&#x27;c&#x27; =&gt; Devcw
	&#x27;w&#x27; =&gt; Devwren
	&#x27;f&#x27; =&gt; Devfworm
	&#x27;p&#x27; =&gt; Devpart
	&#x27;x&#x27; =&gt; Devswab
	&#x27;n&#x27; =&gt; Devnone		# 特別なデバイス</code></pre>
		</section>
		<section>
			<h2>例題</h2>
			<p>以下のデバイス式の場合。</p>
			<pre><code>cw0f{w1w2}</code></pre>
			<p>およそ次のようなデータ構造になる。</p>
			<pre><code>d-&gt;type = Devcw
d-&gt;cw.c = {
	type = Devwren
}
d-&gt;cw.w = {
	type = Devfworm
	fw.fw = {
		type = Devmirr
		cat = w1{type = Devwren} :: w2{type = Devwren}
	}
}
d-&gt;cw.ro = {		# filsys * oで使う; /2010/0705とかを格納する
	type = Devro
	ro-&gt;parent = d
}</code></pre>
			<p>これをふまえて、recoverの処理を追ってみた。</p>
			<section>
				<h3>arginit</h3>
				<pre><code class="c">fs-&gt;flags |= FRECOVER</code></pre>
				<p>後の処理で使うためのフラグ立て。
				recoverコマンドはconfigモードを抜けてはじめて処理される。</p>
			</section>
			<section>
				<h3>sysinit</h3>
				<pre><code class="c">fs-&gt;dev = iconfig(fs-&gt;config)
if(fs-&gt;flags&amp;FRECOVER)
	devrecover(fs-&gt;dev)</code></pre>
			</section>
			<section>
				<h3>devrecover(dev)</h3>
				<pre><code class="c">cwrecover(dev)</code></pre>
				<p>どんどん深くなる。。
				ここで、cwrecoverに渡されるdevは、
				Cache-WORMディスクだけになっている。</p>
			</section>
			<section>
				<h3>cwrecover(dev)</h3>
				<p>WORMのSuperblockを取ってきたりいろいろ。これが肝っぽい。
				WORMのSuperblockを渡り歩いて、
				最新ならそれのアドレスをbaddrにセットしておく。
				これは、最初のSuperblockは固定アドレスにあるが、
				以降は可変のため。</p>
				<p>で、最新のSuperblock(言い換えると最終dump)が定まると、
				続けて各種ブロックアドレスをCacheに設定。</p>
				<pre><code class="c">p = getbuf(wdev, baddr, Bread)
s = (Superb*)p-&gt;iobuf
cb = cacheinit(dev)		# 初期化するだけ
h = (Cache*)cb-&gt;iobuf
h-&gt;sbaddr = baddr
h-&gt;cwraddr = s-&gt;cwraddr</code></pre>
				<p>一部省略したけど、これで終わりっぽい。
				ざっと調べると、Cacheは本当にただのキャッシュで、
				ディスク容量が足りなくなれば、古いキャッシュを一部捨てて、
				新しいキャッシュ用に空きを作るらしい。
				recover直後はまったくキャッシュされていない状態になるのかな。</p>
			</section>
		</section>
		<section>
			<h2>WORMが壊れたとき</h2>
			<p>まだ途中までしか追ってないけど、こっちが壊れたら終わりっぽい。
			なので、最低限ミラーリングしておかないとまずい気がする。
			ミラーしているディスクのうち1台でも残っているなら、
			copydevかcopywormを使えば良さそうな気がするなあ。</p>
			<p>うーん、仮定ばかりだね。あとで調べる。</p>
			<p>もしかして、ディスクを交換したら
			自動でコピーしてくれるのかなと思ったら。</p>
			<section>
				<h3>{w1w2}を初期化する流れ</h3>
				<pre><code>port/main.c:122: main(void)
port/config.c:903: arginit(void)
dev/fworm.c:43: fworminit(Device *d)
port/sub.c:1389: devinit(Device *d)
dev/mworm.c:201: mirrinit(Device *d) </code></pre>
			</section>
			<section>
				<h3>ブロックを読む時</h3>
				<pre><code>dev/mworm.c:233: mirrread(Device *d, Off b, void *c)
	forで配列分ループして、devread() == 0(正常？)なら抜けてる
port/sub.c:1096: devread(Device *d, Off b, void *c)
dev/wren.c:107: wrenread(Device *d, Off b, void *c)
	これらは最終的にはscsiioに帰結してる</code></pre>
			</section>
			<p>ということは、各ミラーの整合性は自分で取れってことかな。</p>
		</section>
		<section>
			<h2>Cacheを新しくするとき</h2>
			<p>たぶんキャッシュが壊れたときと同じでrecoverすればいい。</p>
		</section>
		<section>
			<h2>WORMを新しくするとき</h2>
			<p>あとで</p>
		</section>
		<section>
			<h2>サーバそのものが全壊したとき</h2>
			<p>どうしようね。</p>
			<dl>
			<div>
				<dt>CD/DVD</dt>
				<dd>700M/4G</dd>
			</div>
			<div>
				<dt>Blu-ray</dt>
				<dd>25G</dd>
			</div>
			<div>
				<dt>USB HDD</dt>
				<dd>500Gから</dd>
			</div>
			<div>
				<dt>ネットワーク</dt>
				<dd>?</dd>
			</div>
			</dl>
			<p>プログラムを書いたりhtml書いたりしているだけなので
			まだそんなに容量使ってないけど、
			さすがに光ディスクは現実的ではないと思う。
			とはいえ、どれにしても、allowしないとだめなんだよなあ。。</p>
		</section>
	</section>
</main>
<aside>
	<h1>参照ページ</h1>
	<ul>
	<li><a href="http://plan9.aichi-u.ac.jp/fs/">ファイルシステム</a></li>
	</ul>
</aside>
<aside>
	<h1>やっていること</h1>
	<ul>
	<li><a href="/plan9/index.html"><a>Plan 9</a></a></li>
	<li><a href="http://web.me.com/lufia/alefcompiler/alef/">Alefコンパイラを読む</a></li>
	</ul>
</aside>
<footer>
	<p>見れない、表示がおかしい場合は、動作環境を添えて<a href="/notes/2010/mailto:webmaster@lufia.org"><a>webmaster@lufia.org</a></a>まで連絡ください。</p>
</footer>
</div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"html":"\u003c!doctype html\u003e\n\u003chtml lang=\"ja\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003ctitle\u003eorange/note: fsバックアップメモ\u003c/title\u003e\n\u003cmeta name=\"viewport\" content=\"width=device-width,initial-scale=1\"\u003e\n\u003cmeta name=\"author\" content=\"http://www.hatena.ne.jp/lufiabb/\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cnav\u003e\n\t\u003ch1\u003eメニュー\u003c/h1\u003e\n\t\u003cul\u003e\n\t\u003cli\u003e\u003ca href=\"/notes/index.html\"\u003eorange/note\u003c/a\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ca href=\"/notes/pc.html\"\u003ePC関連\u003c/a\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ca href=\"/notes/web.html\"\u003eweb製作\u003c/a\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ca href=\"/notes/sec.html\"\u003eセキュリティ\u003c/a\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ca href=\"/notes/hobby.html\"\u003e本・ゲーム\u003c/a\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ca href=\"/notes/junk.html\"\u003eジャンク\u003c/a\u003e\u003c/li\u003e\n\t\u003c/ul\u003e\n\u003c/nav\u003e\n\u003cmain\u003e\n\t\u003cp class=\"revision\"\u003e2010年7月5日作成\u003c/p\u003e\n\t\u003csection\u003e\n\t\t\u003ch1\u003efsバックアップメモ\u003c/h1\u003e\n\t\t\u003cp\u003eふと気になったので調べてみました。\n\t\t今までよく無事だったなあ。。\n\t\t単語としては、以下のとおり。\u003c/p\u003e\n\t\t\u003cdl\u003e\n\t\t\u003cdiv\u003e\n\t\t\t\u003cdt\u003eCache-WORM\u003c/dt\u003e\n\t\t\t\u003cdd\u003eキャッシュとWORMのセットになったディスク\u003c/dd\u003e\n\t\t\u003c/div\u003e\n\t\t\u003cdiv\u003e\n\t\t\t\u003cdt\u003eCache\u003c/dt\u003e\n\t\t\t\u003cdd\u003eCache-WORMディスクのCache部分\u003c/dd\u003e\n\t\t\u003c/div\u003e\n\t\t\u003cdiv\u003e\n\t\t\t\u003cdt\u003eWORM\u003c/dt\u003e\n\t\t\t\u003cdd\u003eCache-WORMディスクのWORM部分\u003c/dd\u003e\n\t\t\u003c/div\u003e\n\t\t\u003c/dl\u003e\n\t\t\u003csection\u003e\n\t\t\t\u003ch2\u003eCacheが壊れたとき\u003c/h2\u003e\n\t\t\t\u003cp\u003eたぶん、filsysを再設定して、recover mainで復旧。\n\t\t\tとりあえずディスクタイプを先にまとめ。\u003c/p\u003e\n\t\t\t\u003cpre\u003e\u003ccode\u003edev-\u0026gt;type:\n\t'(' =\u0026gt; Devcat\n\t'[' =\u0026gt; Devmlev\n\t'{' =\u0026gt; Devmirr\n\t'c' =\u0026gt; Devcw\n\t'w' =\u0026gt; Devwren\n\t'f' =\u0026gt; Devfworm\n\t'p' =\u0026gt; Devpart\n\t'x' =\u0026gt; Devswab\n\t'n' =\u0026gt; Devnone\t\t# 特別なデバイス\u003c/code\u003e\u003c/pre\u003e\n\t\t\u003c/section\u003e\n\t\t\u003csection\u003e\n\t\t\t\u003ch2\u003e例題\u003c/h2\u003e\n\t\t\t\u003cp\u003e以下のデバイス式の場合。\u003c/p\u003e\n\t\t\t\u003cpre\u003e\u003ccode\u003ecw0f{w1w2}\u003c/code\u003e\u003c/pre\u003e\n\t\t\t\u003cp\u003eおよそ次のようなデータ構造になる。\u003c/p\u003e\n\t\t\t\u003cpre\u003e\u003ccode\u003ed-\u0026gt;type = Devcw\nd-\u0026gt;cw.c = {\n\ttype = Devwren\n}\nd-\u0026gt;cw.w = {\n\ttype = Devfworm\n\tfw.fw = {\n\t\ttype = Devmirr\n\t\tcat = w1{type = Devwren} :: w2{type = Devwren}\n\t}\n}\nd-\u0026gt;cw.ro = {\t\t# filsys * oで使う; /2010/0705とかを格納する\n\ttype = Devro\n\tro-\u0026gt;parent = d\n}\u003c/code\u003e\u003c/pre\u003e\n\t\t\t\u003cp\u003eこれをふまえて、recoverの処理を追ってみた。\u003c/p\u003e\n\t\t\t\u003csection\u003e\n\t\t\t\t\u003ch3\u003earginit\u003c/h3\u003e\n\t\t\t\t\u003cpre\u003e\u003ccode class=\"c\"\u003efs-\u0026gt;flags |= FRECOVER\u003c/code\u003e\u003c/pre\u003e\n\t\t\t\t\u003cp\u003e後の処理で使うためのフラグ立て。\n\t\t\t\trecoverコマンドはconfigモードを抜けてはじめて処理される。\u003c/p\u003e\n\t\t\t\u003c/section\u003e\n\t\t\t\u003csection\u003e\n\t\t\t\t\u003ch3\u003esysinit\u003c/h3\u003e\n\t\t\t\t\u003cpre\u003e\u003ccode class=\"c\"\u003efs-\u0026gt;dev = iconfig(fs-\u0026gt;config)\nif(fs-\u0026gt;flags\u0026amp;FRECOVER)\n\tdevrecover(fs-\u0026gt;dev)\u003c/code\u003e\u003c/pre\u003e\n\t\t\t\u003c/section\u003e\n\t\t\t\u003csection\u003e\n\t\t\t\t\u003ch3\u003edevrecover(dev)\u003c/h3\u003e\n\t\t\t\t\u003cpre\u003e\u003ccode class=\"c\"\u003ecwrecover(dev)\u003c/code\u003e\u003c/pre\u003e\n\t\t\t\t\u003cp\u003eどんどん深くなる。。\n\t\t\t\tここで、cwrecoverに渡されるdevは、\n\t\t\t\tCache-WORMディスクだけになっている。\u003c/p\u003e\n\t\t\t\u003c/section\u003e\n\t\t\t\u003csection\u003e\n\t\t\t\t\u003ch3\u003ecwrecover(dev)\u003c/h3\u003e\n\t\t\t\t\u003cp\u003eWORMのSuperblockを取ってきたりいろいろ。これが肝っぽい。\n\t\t\t\tWORMのSuperblockを渡り歩いて、\n\t\t\t\t最新ならそれのアドレスをbaddrにセットしておく。\n\t\t\t\tこれは、最初のSuperblockは固定アドレスにあるが、\n\t\t\t\t以降は可変のため。\u003c/p\u003e\n\t\t\t\t\u003cp\u003eで、最新のSuperblock(言い換えると最終dump)が定まると、\n\t\t\t\t続けて各種ブロックアドレスをCacheに設定。\u003c/p\u003e\n\t\t\t\t\u003cpre\u003e\u003ccode class=\"c\"\u003ep = getbuf(wdev, baddr, Bread)\ns = (Superb*)p-\u0026gt;iobuf\ncb = cacheinit(dev)\t\t# 初期化するだけ\nh = (Cache*)cb-\u0026gt;iobuf\nh-\u0026gt;sbaddr = baddr\nh-\u0026gt;cwraddr = s-\u0026gt;cwraddr\u003c/code\u003e\u003c/pre\u003e\n\t\t\t\t\u003cp\u003e一部省略したけど、これで終わりっぽい。\n\t\t\t\tざっと調べると、Cacheは本当にただのキャッシュで、\n\t\t\t\tディスク容量が足りなくなれば、古いキャッシュを一部捨てて、\n\t\t\t\t新しいキャッシュ用に空きを作るらしい。\n\t\t\t\trecover直後はまったくキャッシュされていない状態になるのかな。\u003c/p\u003e\n\t\t\t\u003c/section\u003e\n\t\t\u003c/section\u003e\n\t\t\u003csection\u003e\n\t\t\t\u003ch2\u003eWORMが壊れたとき\u003c/h2\u003e\n\t\t\t\u003cp\u003eまだ途中までしか追ってないけど、こっちが壊れたら終わりっぽい。\n\t\t\tなので、最低限ミラーリングしておかないとまずい気がする。\n\t\t\tミラーしているディスクのうち1台でも残っているなら、\n\t\t\tcopydevかcopywormを使えば良さそうな気がするなあ。\u003c/p\u003e\n\t\t\t\u003cp\u003eうーん、仮定ばかりだね。あとで調べる。\u003c/p\u003e\n\t\t\t\u003cp\u003eもしかして、ディスクを交換したら\n\t\t\t自動でコピーしてくれるのかなと思ったら。\u003c/p\u003e\n\t\t\t\u003csection\u003e\n\t\t\t\t\u003ch3\u003e{w1w2}を初期化する流れ\u003c/h3\u003e\n\t\t\t\t\u003cpre\u003e\u003ccode\u003eport/main.c:122: main(void)\nport/config.c:903: arginit(void)\ndev/fworm.c:43: fworminit(Device *d)\nport/sub.c:1389: devinit(Device *d)\ndev/mworm.c:201: mirrinit(Device *d) \u003c/code\u003e\u003c/pre\u003e\n\t\t\t\u003c/section\u003e\n\t\t\t\u003csection\u003e\n\t\t\t\t\u003ch3\u003eブロックを読む時\u003c/h3\u003e\n\t\t\t\t\u003cpre\u003e\u003ccode\u003edev/mworm.c:233: mirrread(Device *d, Off b, void *c)\n\tforで配列分ループして、devread() == 0(正常？)なら抜けてる\nport/sub.c:1096: devread(Device *d, Off b, void *c)\ndev/wren.c:107: wrenread(Device *d, Off b, void *c)\n\tこれらは最終的にはscsiioに帰結してる\u003c/code\u003e\u003c/pre\u003e\n\t\t\t\u003c/section\u003e\n\t\t\t\u003cp\u003eということは、各ミラーの整合性は自分で取れってことかな。\u003c/p\u003e\n\t\t\u003c/section\u003e\n\t\t\u003csection\u003e\n\t\t\t\u003ch2\u003eCacheを新しくするとき\u003c/h2\u003e\n\t\t\t\u003cp\u003eたぶんキャッシュが壊れたときと同じでrecoverすればいい。\u003c/p\u003e\n\t\t\u003c/section\u003e\n\t\t\u003csection\u003e\n\t\t\t\u003ch2\u003eWORMを新しくするとき\u003c/h2\u003e\n\t\t\t\u003cp\u003eあとで\u003c/p\u003e\n\t\t\u003c/section\u003e\n\t\t\u003csection\u003e\n\t\t\t\u003ch2\u003eサーバそのものが全壊したとき\u003c/h2\u003e\n\t\t\t\u003cp\u003eどうしようね。\u003c/p\u003e\n\t\t\t\u003cdl\u003e\n\t\t\t\u003cdiv\u003e\n\t\t\t\t\u003cdt\u003eCD/DVD\u003c/dt\u003e\n\t\t\t\t\u003cdd\u003e700M/4G\u003c/dd\u003e\n\t\t\t\u003c/div\u003e\n\t\t\t\u003cdiv\u003e\n\t\t\t\t\u003cdt\u003eBlu-ray\u003c/dt\u003e\n\t\t\t\t\u003cdd\u003e25G\u003c/dd\u003e\n\t\t\t\u003c/div\u003e\n\t\t\t\u003cdiv\u003e\n\t\t\t\t\u003cdt\u003eUSB HDD\u003c/dt\u003e\n\t\t\t\t\u003cdd\u003e500Gから\u003c/dd\u003e\n\t\t\t\u003c/div\u003e\n\t\t\t\u003cdiv\u003e\n\t\t\t\t\u003cdt\u003eネットワーク\u003c/dt\u003e\n\t\t\t\t\u003cdd\u003e?\u003c/dd\u003e\n\t\t\t\u003c/div\u003e\n\t\t\t\u003c/dl\u003e\n\t\t\t\u003cp\u003eプログラムを書いたりhtml書いたりしているだけなので\n\t\t\tまだそんなに容量使ってないけど、\n\t\t\tさすがに光ディスクは現実的ではないと思う。\n\t\t\tとはいえ、どれにしても、allowしないとだめなんだよなあ。。\u003c/p\u003e\n\t\t\u003c/section\u003e\n\t\u003c/section\u003e\n\u003c/main\u003e\n\u003caside\u003e\n\t\u003ch1\u003e参照ページ\u003c/h1\u003e\n\t\u003cul\u003e\n\t\u003cli\u003e\u003ca href=\"http://plan9.aichi-u.ac.jp/fs/\"\u003eファイルシステム\u003c/a\u003e\u003c/li\u003e\n\t\u003c/ul\u003e\n\u003c/aside\u003e\n\u003caside\u003e\n\t\u003ch1\u003eやっていること\u003c/h1\u003e\n\t\u003cul\u003e\n\t\u003cli\u003e\u003ca href=\"/plan9/index.html\"\u003ePlan 9\u003c/a\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003ca href=\"http://web.me.com/lufia/alefcompiler/alef/\"\u003eAlefコンパイラを読む\u003c/a\u003e\u003c/li\u003e\n\t\u003c/ul\u003e\n\u003c/aside\u003e\n\u003cfooter\u003e\n\t\u003cp\u003e見れない、表示がおかしい場合は、動作環境を添えて\u003ca href=\"mailto:webmaster@lufia.org\"\u003ewebmaster@lufia.org\u003c/a\u003eまで連絡ください。\u003c/p\u003e\n\u003c/footer\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/[[...slug]]","query":{"slug":["notes","2010","0705"]},"buildId":"uudkrhSA2meQW-38gm1fk","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>