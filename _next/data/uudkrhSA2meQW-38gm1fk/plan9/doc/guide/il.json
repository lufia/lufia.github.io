{"pageProps":{"html":"<!doctype html>\n<html lang=\"ja\">\n<head>\n<meta charset=\"utf-8\">\n<title>Plan 9: ILプロトコル</title>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n<meta name=\"author\" content=\"http://www.hatena.ne.jp/lufiabb/\">\n</head>\n<body>\n<nav>\n\t<h1>メニュー</h1>\n\t<ul>\n\t<li><a href=\"/plan9/index.html\">Plan 9</a></li>\n\t<li><a href=\"/plan9/doc/inst/index.html\">インストール</a></li>\n\t<li><a href=\"/plan9/doc/guide/index.html\">システムの使い方</a></li>\n\t<li><a href=\"/plan9/doc/devel/index.html\">プログラミング</a></li>\n\t<li><a href=\"/plan9/doc/adm/index.html\">システム管理</a></li>\n\t<li><a href=\"/plan9/man/index.html\">自作ツール集</a></li>\n\t</ul>\n</nav>\n<main>\n\t<p>ILの論文をおおよそ意訳でやってみました。\n\tそれと、いろいろコメントやらリンクやらを張っていますが、\n\tこれらは勝手につけたものだったり、未訳だったりです。</p>\n\t<p class=\"revision\">2011年6月17日作成</p>\n\t<section>\n\t\t<h1>ILプロトコル</h1>\n\t\t<p>Plan 9ファイルシステムプロトコル9PのRPCメッセージを転送するため、\n\t\tILと呼ぶ新しいネットワークプロトコルを実装しました。\n\t\tこれはコネクション型のプロトコルで、\n\t\tIPによってカプセル化されたデータグラムを運ぶ軽量なプロトコルです。\n\t\tILは消失したパケットの再送と順序通りの配達を提供しますが、<a href=\"http://net-juku.org/tcpip/tcpip102.html\">フロー制御</a>と暗黙的な再送はしません。</p>\n\t\t<p class=\"note\">暗黙的な再送はおそらく、tcpでの<a href=\"http://www.7key.jp/nw/tcpip/tcp/tcp2.html\">再送依頼を受けたらそれ以降を再送</a>するところかな。\n\t\tILはstateで受けたackの次にあるデータしか再送しないです。</p>\n\t\t<section>\n\t\t\t<h2>導入</h2>\n\t\t\t<p>Plan 9は、RPCリクエストとレスポンスメッセージに、\n\t\t\tメッセージ区切りがあり、順序保証を要求するプロトコル(9P)を使います。\n\t\t\t標準IPプロトコルのどれも、9Pメッセージの転送に適切ではありません。\n\t\t\tTCPは高いオーバーヘッドがあり、メッセージの区切りがありません。\n\t\t\tUDPは、単純でメッセージ区切りを持つとはいえ、順序保証がありません。\n\t\t\t我々は自分たちのシステムにIP, TCP, UDPを実装していたとき、\n\t\t\t9Pに適したプロトコルを選別しようとしました。\n\t\t\t要求する性質は:</p>\n\t\t\t<ul>\n\t\t\t<li>信頼性のあるデータグラムサービス</li>\n\t\t\t<li>順番通りの配達</li>\n\t\t\t<li>IPネットワーク</li>\n\t\t\t<li>シンプルで高パフォーマンス</li>\n\t\t\t<li>柔軟なタイムアウト</li>\n\t\t\t</ul>\n\t\t\t<p>標準プロトコルには上記を満たすものが無かったので、\n\t\t\tIL(Internet Link)と呼ばれる新しいプロトコルを設計しました。</p>\n\t\t\t<p>ILは軽量な、IPの上位プロトコルです。\n\t\t\tこれはコネクション指向で、メッセージの到着順を保証します。\n\t\t\tクライアントサーバ間でRPCメッセージを転送するために設計されたので、\n\t\t\tフロー制御はなく、構造は固有のフロー制約を含みます。</p>\n\t\t\t<div class=\"note\">\n\t\t\t\t<p>未解決メッセージ用の小さい窓は、多すぎる受信を防ぐ,\n\t\t\t\tバッファされつつあるところからの;</p>\n\t\t\t</div>\n\t\t\t<p>ウインドウからあふれたメッセージは捨てられ、再送されなければなりません。\n\t\t\tコネクションの確立時に接続の両端でシーケンス番号の初期値を生成するため、\n\t\t\t2wayハンドシェイクを使います; 続くデータメッセージは、\n\t\t\t受信側でバラバラになったメッセージを再並べ替えできるようにするため、\n\t\t\tシーケンス番号をインクリメントします。\n\t\t\t他のプロトコルとは対照的に、ILは暗黙的な再送が無効です。\n\t\t\tこれは混雑したネットワークにおいて、\n\t\t\t暗黙的な再送によってより混雑させるのを防ぎます。\n\t\t\tTCPに似て、ILは往復時間によってタイムアウトを決定しますので、\n\t\t\tインターネットとローカルイーサネットのどちらでも上手に動きます。\n\t\t\tネットワーク速度に適した肯定応答と再送の時間を見積もるために、\n\t\t\t往復時間(RTT; round-trip timer)を使います。</p>\n\t\t</section>\n\t\t<section>\n\t\t\t<h2>コネクション</h2>\n\t\t\t<p>ILコネクションは接続している端から端へデータストリームを運びます。\n\t\t\tコネクションが維持されている間、\n\t\t\t片側に入ったデータは入れた順に逆側へ送られます。\n\t\t\t図1は、状態(円)とその変遷(弧)で\n\t\t\tコネクションの機能を描いたステートマシンです。\n\t\t\tそれぞれの変遷は、水平線の上が変化の原因となったイベントで、\n\t\t\t下には、このときに受信または送信するメッセージを表しています。\n\t\t\tこの論文の残りは、このステートマシンについて議論します。</p>\n\t\t\t<p>&lt;図1&gt;, 原文をみてください。</p>\n\t\t\t<div class=\"note\">\n\t\t\t\t<p>snd(packet)は相手側へpacketを送信する。\n\t\t\t\trcv(packet)は受信。</p>\n\t\t\t\t<p>packetはtype(seq, ack)かな？typeはsyncとかdataとか。</p>\n\t\t\t</div>\n\t\t\t<dl>\n\t\t\t<div>\n\t\t\t\t<dt>ackok</dt>\n\t\t\t\t<dd>any sequence number between id0 and next inclusive</dd>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<dt>!x</dt>\n\t\t\t\t<dd>xを除くなんらかの値</dd>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<dt>-</dt>\n\t\t\t\t<dd>なんらかの値</dd>\n\t\t\t</div>\n\t\t\t</dl>\n\t\t\t<p>ILステートマシンには、Closed, Syncer, Syncee,\n\t\t\tEstablished, Closingという5つの状態があります。\n\t\t\tコネクションは両端のIPアドレスとポート番号によって識別されます。\n\t\t\tアドレスはIPプロトコルヘッダにあり、\n\t\t\tポート番号は18バイトのILヘッダにあります。\n\t\t\tコネクションごとに固有の変数は:</p>\n\t\t\t<dl>\n\t\t\t<div>\n\t\t\t\t<dt>state</dt>\n\t\t\t\t<dd>Closed, Syncer, Syncee, Established, Closingのどれか</dd>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<dt>laddr</dt>\n\t\t\t\t<dd>32bitローカルIPアドレス</dd>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<dt>lport</dt>\n\t\t\t\t<dd>16bitローカルILポート番号</dd>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<dt>raddr</dt>\n\t\t\t\t<dd>32bitリモートIPアドレス</dd>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<dt>rport</dt>\n\t\t\t\t<dd>16bitリモートILポート番号</dd>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<dt>id0</dt>\n\t\t\t\t<dd>32bitシーケンス番号(ローカル側)</dd>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<dt>rid0</dt>\n\t\t\t\t<dd>32bitシーケンス番号(リモート側)</dd>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<dt>next</dt>\n\t\t\t\t<dd>ローカル側から送られる次のシーケンス番号</dd>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<dt>rcvd</dt>\n\t\t\t\t<dd>正常に受信した最後のリモート側番号</dd>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<dt>unacked</dt>\n\t\t\t\t<dd>まだACKを受け取っていない最初のシーケンス番号(ローカル側)</dd>\n\t\t\t</div>\n\t\t\t</dl>\n\t\t\t<p>接続は最初、未割当アドレスでClosedになっています。\n\t\t\tまだ接続されていないコネクションへメッセージが届くか、\n\t\t\tまたはユーザが明確に接続すると、コネクションをオープンします。\n\t\t\t最初の場合、メッセージの送信元アドレスとポートがリモート側のそれになり、\n\t\t\t送信先はローカル側として処理します。\n\t\t\tこのとき、コネクションの状態はSynceeです。2つ目の場合は、\n\t\t\tユーザがローカルとリモート両方のアドレスとポートを明示します。\n\t\t\tコネクションの状態はSyncerになり、\n\t\t\tsyncメッセージがリモート側に送られます。\n\t\t\tローカルアドレスの正当な値はIPの実装によります。</p>\n\t\t</section>\n\t\t<section>\n\t\t\t<h2>シーケンス番号</h2>\n\t\t\t<p>ILはデータメッセージを運びます。\n\t\t\t各メッセージはOSからのwrite命令1回分に対応し、\n\t\t\tそれは32bitシーケンス番号により識別されます。\n\t\t\tコネクション両側の初期シーケンス番号はランダムで、\n\t\t\t最初のsyncメッセージで伝えます。\n\t\t\t番号は、続くデータメッセージごとにインクリメントされます。\n\t\t\t再送されたメッセージのシーケンス番号は、最初に送った番号です。</p>\n\t\t</section>\n\t\t<section>\n\t\t\t<h2>送信/再送</h2>\n\t\t\t<div class=\"note\">\n\t\t\t\t<dl>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>acknowledgement</dt>\n\t\t\t\t\t<dd>受信確認</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>acknowledge</dt>\n\t\t\t\t\t<dd>承認</dd>\n\t\t\t\t</div>\n\t\t\t\t</dl>\n\t\t\t</div>\n\t\t\t<p>各メッセージは識別子(ID)と受信確認(ACK)という\n\t\t\t2つのシーケンス番号を持ちます。ACKは、\n\t\t\tリモート側で順序正しく受信を確認したシーケンス番号の最大値です。\n\t\t\tdataとdataqueryメッセージの場合、IDはそのシーケンス番号です。\n\t\t\tsync, ack, query, state, closeといったコントロールメッセージでは、\n\t\t\tIDは送ったデータメッセージの最大シーケンス番号より1大きい。</p>\n\t\t\t<div class=\"note\">\n\t\t\t\t<p>よく分かっていないけど、\n\t\t\t\tdata(201, -)で送った後にsync, ackと続く場合、\n\t\t\t\tどちらもIDは202になるということなのかな。\n\t\t\t\tで、その後に送られるdataもIDは202ですが、\n\t\t\t\tおそらくここでインクリメント。次からIDは203になる。</p>\n\t\t\t\t<p>ソースを読むと、ilackq関数でunackedに追加するのですが、\n\t\t\t\tこれはilkick関数(データの送信)からしか呼び出していないので\n\t\t\t\tたぶんあってる。nextを増やしているのもilkickだけだし、\n\t\t\t\tコントロールメッセージは受信したらすぐ応答しているし。</p>\n\t\t\t</div>\n\t\t\t<p>送信者はデータメッセージをdata型として送ります。\n\t\t\tACKが返送メッセージに含まれています。\n\t\t\tデータを受信してから200msec以内に返送していない場合、\n\t\t\tackメッセージが送られるでしょう。</p>\n\t\t\t<p>IPでは、順序が入れ違ったり、混雑により消失したり、\n\t\t\t失敗したりするかもしれません。これを克服し、かつネットワークを\n\t\t\t混雑させないために、ILは改良した<a href=\"http://otsubo.info/contents/network/network06.html\">go back nプロトコル</a>を使います。\n\t\t\t平均RTT(round trip time)は、メッセージの送信と\n\t\t\tそのACKを受け取った遅延を計測することによって保たれます。\n\t\t\tいちども承認を受信していなければ、平均RTTを100msecだと仮定します。\n\t\t\t受信確認がまだされていないメッセージでいちばん古いものについて、\n\t\t\tRTTを4回過ぎても受信確認がない場合(図1ではrexmit timeout)は、\n\t\t\tILはメッセージか受信確認のどちらかが消失したと判断します。\n\t\t\tこのとき、送信者は最初の未承認メッセージだけをdataquery型で再送します。\n\t\t\t受信者はdataqueryを受信すると、順番に受信したデータメッセージの\n\t\t\t最大ACKをstateメッセージで応答します。\n\t\t\tこれはたぶん、再送されたメッセージのシーケンス番号、または\n\t\t\t(受信者が今までにため込んでいるメッセージの順序が狂ったなら)\n\t\t\tより大きい正常に受信したシーケンス番号でしょう。\n\t\t\t受信者が、順序が狂ったメッセージを保存するかどうかは実装によります。\n\t\t\t我々の実装では前方向に10パケットため込みます。\n\t\t\t送信者はstateメッセージを受信したとき、\n\t\t\tすぐに次の未承認なメッセージをdataquery型で再送します。\n\t\t\tこれは全てのメッセージが承認されるまで続けられます。</p>\n\t\t\t<div class=\"note\">\n\t\t\t\t<dl>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>sync</dt>\n\t\t\t\t\t<dd>最初の2wayハンドシェイク</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>data</dt>\n\t\t\t\t\t<dd>ふつうのデータパケット</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>dataquery</dt>\n\t\t\t\t\t<dd>ひとつのシーケンス番号だけ再送要求</dd>\n\t\t\t\t\t<dd>stateを返す</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>ack</dt>\n\t\t\t\t\t<dd>ack</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>query</dt>\n\t\t\t\t\t<dd>データを持たないdataquery</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>state</dt>\n\t\t\t\t\t<dd>正常受信した最大シーケンス番号パケット</dd>\n\t\t\t\t\t<dd>未承認パケットがあればdataqueryを返す</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>close</dt>\n\t\t\t\t\t<dd>close</dd>\n\t\t\t\t</div>\n\t\t\t\t</dl>\n\t\t\t</div>\n\t\t\t<p>もし、dataqueryの後にACKが届かないなら、\n\t\t\tタイムアウトの後、送信者はdataqueryメッセージの再送を続けます。\n\t\t\t再送の間隔は指数関数的に増大します。\n\t\t\t最後に受信してから300秒経過した後(図1のdeath timeout)、\n\t\t\t送信者はあきらめて接続が切れたと判断します。</p>\n\t\t\t<p>再送は、Syncer, Syncee, Close状態でも起こります。\n\t\t\tその再送間隔はデータメッセージと同等です。</p>\n\t\t</section>\n\t\t<section>\n\t\t\t<h2>Keep Alive</h2>\n\t\t\t<p>切れた接続は発見され、リソースを消費しないように取り壊さなければなりません。\n\t\t\t生きているシステムだとしても、これ以上データも受信確認も送らないなら、\n\t\t\t今までに述べたプロトコルは、これらの接続を発見しません。</p>\n\t\t\t<div class=\"note\">\n\t\t\t\t<p>このあたり翻訳があやしい。</p>\n\t\t\t</div>\n\t\t\t<p>したがって、Established状態において、最後に送信してから6秒間、\n\t\t\t他にメッセージが無いなら、queryを送ります。\n\t\t\t受信者はいつでも、stateメッセージでqueryに応答します。\n\t\t\tもし最後に受信してから30秒間メッセージが届かなければ、\n\t\t\t接続は閉じられます。これは図1に描かれていません。</p>\n\t\t</section>\n\t\t<section>\n\t\t\t<h2>バイトオーダー</h2>\n\t\t\t<p>すべての32bitと16bit数は<a href=\"http://www.atmarkit.co.jp/icd/root/72/116970472.html\">ネットワークバイトオーダー</a>です。</p>\n\t\t</section>\n\t\t<section>\n\t\t\t<h2>フォーマット</h2>\n\t\t\t<p>以下は、IPオプションを無いものとして、\n\t\t\tC言語で記述したIP+ILヘッダです。</p>\n\t\t\t<pre><code class=\"c\">typedef unsigned char byte;\nstruct IPIL\n{\n\tbyte vihl;\t/* バージョンとヘッダ長 */\n\tbyte tos;\t/* type of service */\n\tbyte length[2];\t/* パケット長 */\n\tbyte id[2];\t/* Identification */\n\tbyte frag[2];\t/* フラグメント情報 */\n\tbyte ttl;\t/* Time to live */\n\tbyte proto;\t/* プロトコル */\n\tbyte cksum[2];\t/* ヘッダのチェックサム */\n\tbyte src[4];\t/* IP送信元 */\n\tbyte dst[4];\t/* IP送信先 */\n\tbyte ilsum[2];\t/* ヘッダを含めたチェックサム */\n\tbyte illen[2];\t/* パケット長 */\n\tbyte iltype;\t/* パケットタイプ */\n\tbyte ilspec;\t/* special */\n\tbyte ilsrc[2];\t/* 送信元ポート番号 */\n\tbyte ildst[2];\t/* 送信先ポート番号 */\n\tbyte ilid[4];\t/* シーケンス番号 */\n\tbyte ilack[4];\t/* ACK */\n};</code></pre>\n\t\t\t<p>データはヘッダのすぐ下です。\n\t\t\tilspecは将来のために予約されているフィールドです。</p>\n\t\t\t<p>チェックサムはilsumとilspecを0にしたうえで計算されます。\n\t\t\tこれは標準IPチェックサムで、\n\t\t\tthat is, the 16-bit one's complement of the one's complement sum of\n\t\t\tall 16 bit words in the header and text.\n\t\t\tもしメッセージのヘッダとテキストのバイト数が奇数なら、\n\t\t\t上位バイトを0で詰めた16bit数として扱います。</p>\n\t\t\t<p>チェックサムはcksumからデータの終わりまでをカバーします。</p>\n\t\t\t<p>有効なiltype値は:</p>\n\t\t\t<pre><code class=\"c\">enum {\n\tsync=\t\t0,\n\tdata=\t\t1,\n\tdataquery=\t2,\n\tack=\t\t3,\n\tquery=\t\t4,\n\tstate=\t\t5,\n\tclose=\t\t6,\n};</code></pre>\n\t\t\t<p>illenフィールドはILヘッダとデータのバイト数です。</p>\n\t\t</section>\n\t\t<section>\n\t\t\t<h2>Numbers</h2>\n\t\t\t<p>IL用のIPプロトコル番号は40。\n\t\t\t割り当てられたILポート番号:</p>\n\t\t\t<dl>\n\t\t\t<div>\n\t\t\t\t<dt>7</dt>\n\t\t\t\t<dd>echo all input to output</dd>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<dt>9</dt>\n\t\t\t\t<dd>discard input</dd>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<dt>19</dt>\n\t\t\t\t<dd>send a standard pattern to output</dd>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<dt>565</dt>\n\t\t\t\t<dd>send IP addresses of caller and callee to output</dd>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<dt>566</dt>\n\t\t\t\t<dd>Plan 9認証プロトコル</dd>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<dt>17005</dt>\n\t\t\t\t<dd>Plan 9 CPUサービス, データ</dd>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<dt>17006</dt>\n\t\t\t\t<dd>Plan 9 CPUサービス, notes(シグナルのようなもの)</dd>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<dt>17007</dt>\n\t\t\t\t<dd>Plan 9 exported file systems</dd>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<dt>17008</dt>\n\t\t\t\t<dd>Plan 9ファイルサービス</dd>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<dt>17009</dt>\n\t\t\t\t<dd>Plan 9 remote execution</dd>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<dt>17030</dt>\n\t\t\t\t<dd>Alef Name Server</dd>\n\t\t\t</div>\n\t\t\t</dl>\n\t\t</section>\n\t\t<section>\n\t\t\t<h2>参照</h2>\n\t\t\t<ul>\n\t\t\t<li>The Use of Name Spaces in Plan 9</li>\n\t\t\t<li>RFC791, Internet Protocol</li>\n\t\t\t<li>RFC793, Transmission Control Protocol</li>\n\t\t\t<li>RFC768, RFC768, User Datagram Protocol</li>\n\t\t\t</ul>\n\t\t</section>\n\t</section>\n</main>\n<aside>\n\t<h1>関連情報</h1>\n\t<ul>\n\t<li><a href=\"https://9p.io/sys/doc/il/il.pdf\">原文(PDF)</a></li>\n\t<li><a href=\"../../../notes/2011/0618.html\">il.cを読む</a></li>\n\t<li><a href=\"../inst/il.html\">カーネルにilを組み込む</a></li>\n\t</ul>\n</aside>\n<footer>\n\t<p>見れない、表示がおかしい場合は、動作環境を添えて<a href=\"mailto:webmaster@lufia.org\">webmaster@lufia.org</a>まで連絡ください。</p>\n</footer>\n</body>\n</html>\n"},"__N_SSG":true}