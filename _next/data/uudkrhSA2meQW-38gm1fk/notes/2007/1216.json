{"pageProps":{"html":"<!doctype html>\n<html lang=\"ja\">\n<head>\n<meta charset=\"utf-8\">\n<title>orange/note: バンドデータ処理プログラム</title>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n<meta name=\"author\" content=\"http://www.hatena.ne.jp/lufiabb/\">\n</head>\n<body>\n<nav>\n\t<h1>メニュー</h1>\n\t<ul>\n\t<li><a href=\"/notes/index.html\">orange/note</a></li>\n\t<li><a href=\"/notes/pc.html\">PC関連</a></li>\n\t<li><a href=\"/notes/web.html\">web製作</a></li>\n\t<li><a href=\"/notes/sec.html\">セキュリティ</a></li>\n\t<li><a href=\"/notes/hobby.html\">本・ゲーム</a></li>\n\t<li><a href=\"/notes/junk.html\">ジャンク</a></li>\n\t</ul>\n</nav>\n<main>\n\t<p class=\"revision\">2009年9月30日更新</p>\n\t<section>\n\t\t<h1>バンドデータ処理プログラム</h1>\n\t\t<p><a href=\"http://blog.nizah.net/nb/2007/12/13/band-code.html\">Nizah Blogのお題</a>を\n\t\tLimboで解いてみました。</p>\n\t\t<p>タプルと配列スライスが使えるから少し便利ですが、\n\t\tそれ以外は、ほとんどCになってしまいました。。</p>\n\t\t<p>それから、ソートが言語に含まれなくて、関数ポインタを渡す方法が\n\t\t分からなかったので、ソートの比較はいっぱい無理してます。\n\t\t単純にYear: con 0;とかでもよかったけどね。</p>\n\t\t<pre><code class=\"c\">implement Band;\n\ninclude &quot;sys.m&quot;;\n\tsys: Sys;\n\tprint: import sys;\ninclude &quot;draw.m&quot;;\ninclude &quot;string.m&quot;;\n\tstr: String;\n\nBand: module\n{\n\tinit: fn(ctxt: ref Draw-&gt;Context, argv: list of string);\n};\n\nOrder: adt {\n\tpick {\n\tYear or Name =&gt;\n\t}\n};\n\ninit(nil: ref Draw-&gt;Context, nil: list of string)\n{\n\tsys = load Sys Sys-&gt;PATH;\n\tstr = load String String-&gt;PATH;\n\tname := array[] of { &quot;The Beatles&quot;, &quot;KRAFTWERK&quot;, &quot;Queen&quot;, &quot;B'z&quot;, &quot;ThE Foo Bar&quot; };\n\tyear := array[] of { 60, 1970, 70, 88, 2007 };\n\tcountry := array[] of { &quot;UK&quot;, &quot;DE&quot;, &quot;UK&quot;, &quot;JP&quot;, &quot;US&quot; };\n\n\t# ex 1\n\tband := array[len name] of (string, int, string);\n\tfor(i := 0; i &lt; len name; i++)\n\t\tband[i] = (name[i], year[i], country[i]);\n\n\t# ex 2\n\tband2 := array[len band] of (string, int, string);\n\tband2[0:] = band;\n\tsort(band2, len band2, ref Order.Year);\n\tfor(i = 0; i &lt; len band2; i++){\n\t\t(b1, b2, b3) := band2[i];\n\t\tprint(&quot;%s,%d,%s\\n&quot;, b1, b2, b3);\n\t}\n\n\t# ex 3\n\tsorted_band := array[len band] of (string, int, string);\n\tsorted_band[0:] = band;\n\tsort(sorted_band, len sorted_band, ref Order.Name);\n\n\t# ex 4\n\tprint(&quot;\\n&quot;);\n\tfor(i = 0; i &lt; len sorted_band; i++){\n\t\t(b1, b2, b3) := correct(sorted_band[i]);\n\t\tthe := &quot;&quot;;\n\t\tif(str-&gt;tolower(b1[0:3]) == &quot;the&quot;){\n\t\t\tthe = &quot;(&quot; + b1[0:3] + &quot;)&quot;;\n\t\t\tb1 = b1[4:];\n\t\t}\n\t\tprint(&quot;%-6s%-15s%d %s\\n&quot;, the, b1, b2, b3);\n\t}\n}\n\nsort(a: array of (string, int, string), r: int, order: ref Order)\n{\n\tsort1(a, array[len a] of (string, int, string), r, order);\n}\n\nsort1(a, b: array of (string, int, string), r: int, order: ref Order)\n{\n\tif(r &gt; 1){\n\t\tm := (r-1)/2 + 1;\n\t\tsort1(a[0:m], b[0:m], m, order);\n\t\tsort1(a[m:r], b[m:r], r-m, order);\n\t\tb[0:] = a[0:r];\n\t\tfor((i, j, k) := (0, m, 0); i &lt; m &amp;&amp; j &lt; r; k++){\n\t\t\tcmp: int;\n\t\t\tpick c := order {\n\t\t\tYear =&gt;\n\t\t\t\tcmp = yearcmp(b[i], b[j]);\n\t\t\tName =&gt;\n\t\t\t\tcmp = namecmp(b[i], b[j]);\n\t\t\t* =&gt;\n\t\t\t\traise &quot;fail:order&quot;;\n\t\t\t}\n\t\t\tif(cmp &gt; 0)\n\t\t\t\ta[k] = b[j++];\n\t\t\telse\n\t\t\t\ta[k] = b[i++];\n\t\t}\n\t\tif(i &lt; m)\n\t\t\ta[k:] = b[i:m];\n\t\telse if(j &lt; r)\n\t\t\ta[k:] = b[j:r];\n\t}\n}\n\nyearcmp(b1: (string, int, string), b2: (string, int, string)): int\n{\n\t(nil, y1, c1) := correct(b1);\n\t(nil, y2, c2) := correct(b2);\n\tif(y1 &gt; y2)\n\t\treturn 1;\n\telse if(y1 &lt; y2)\n\t\treturn -1;\n\n\tif(c1 &gt; c2)\n\t\treturn 1;\n\telse if(c1 == c2)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}\n\nnamecmp(b1: (string, int, string), b2: (string, int, string)): int\n{\n\tname1 := namei(b1);\n\tname2 := namei(b2);\n\tif(name1 &gt; name2)\n\t\treturn 1;\n\telse if(name1 == name2)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}\n\ncorrect(band: (string, int, string)): (string, int, string)\n{\n\t(name, year, country) := band;\n\tif(year &lt; 100)\n\t\tyear += 1900;\n\treturn (name, year, country);\n}\n\nnamei(band: (string, int, string)): string\n{\n\t(name, nil, nil) := band;\n\tname = str-&gt;tolower(name);\n\tif(name[0:3] == &quot;the&quot;)\n\t\tname = name[4:];\n\treturn name;\n}</code></pre>\n\t\t<p>2文字以下のバンド名(&quot;X&quot;など)が初期データにあると落ちる。\n\t\ttheの判定のところでname[0:3]が配列境界を越えるから。</p>\n\t\t<section>\n\t\t\t<h2>2009年9月30日追記</h2>\n\t\t\t<p>関数ポインタは、ref fn()のように書くと渡せる。</p>\n\t\t\t<pre><code class=\"c\">implement Fn;\n\ninclude &quot;sys.m&quot;;\n\tsys: Sys;\ninclude &quot;draw.m&quot;;\n\nFn: module\n{\n\tinit: fn(ctxt: ref Draw-&gt;Context, argv: list of string);\n};\n\nInt: adt\n{\n\tn: int;\n};\n\ninit(nil: ref Draw-&gt;Context, nil: list of string)\n{\n\tsys = load Sys Sys-&gt;PATH;\n\n\tA1 := array[] of { &quot;a1&quot;, &quot;b2&quot;, &quot;c3&quot; };\n\tA2 := array[] of { ref Int(1), ref Int(2), ref Int(3) };\n\n\tapply(A1, printstring);\n\tapply(A2, printint);\n}\n\napply[T](a: array of T, f: ref fn(p: T))\n{\n\tfor(i := 0; i &lt; len a; i++)\n\t\tf(a[i]);\n}\n\nprintint(n: ref Int)\n{\n\tsys-&gt;print(&quot;%d\\n&quot;, n.n);\n}\n\nprintstring(s: string)\n{\n\tsys-&gt;print(&quot;%s\\n&quot;, s);\n}</code></pre>\n\t\t\t<p>qsortの比較関数プロトタイプなど、Cでvoid*を使う状況では、\n\t\t\tパラメトリック多相型というものが同じような目的に使える。\n\t\t\t上記の例でいえば、apply関数で使っているT型。\n\t\t\tこれは、ref型しか扱えない(型の解決ができない)という制限があるので、\n\t\t\tintを直接扱うといったことはできない。</p>\n\t\t</section>\n\t</section>\n</main>\n<aside>\n\t<h1>参考サイト</h1>\n\t<ul>\n\t<li><a href=\"http://alohakun.blog7.fc2.com/blog-entry-730.html\">Limboのパラメトリック多相</a></li>\n\t</ul>\n</aside>\n<aside>\n\t<h1>やっていること</h1>\n\t<ul>\n\t<li><a href=\"/plan9/index.html\">Plan 9</a></li>\n\t<li><a href=\"http://web.me.com/lufia/alefcompiler/alef/\">Alefコンパイラを読む</a></li>\n\t</ul>\n</aside>\n<footer>\n\t<p>見れない、表示がおかしい場合は、動作環境を添えて<a href=\"mailto:webmaster@lufia.org\">webmaster@lufia.org</a>まで連絡ください。</p>\n</footer>\n</body>\n</html>\n"},"__N_SSG":true}