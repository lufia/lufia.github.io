{"pageProps":{"html":"<!doctype html>\n<html lang=\"ja\">\n<head>\n<meta charset=\"utf-8\">\n<title>orange/note: fsバックアップメモ</title>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n<meta name=\"author\" content=\"http://www.hatena.ne.jp/lufiabb/\">\n</head>\n<body>\n<nav>\n\t<h1>メニュー</h1>\n\t<ul>\n\t<li><a href=\"/notes/index.html\">orange/note</a></li>\n\t<li><a href=\"/notes/pc.html\">PC関連</a></li>\n\t<li><a href=\"/notes/web.html\">web製作</a></li>\n\t<li><a href=\"/notes/sec.html\">セキュリティ</a></li>\n\t<li><a href=\"/notes/hobby.html\">本・ゲーム</a></li>\n\t<li><a href=\"/notes/junk.html\">ジャンク</a></li>\n\t</ul>\n</nav>\n<main>\n\t<p class=\"revision\">2010年7月5日作成</p>\n\t<section>\n\t\t<h1>fsバックアップメモ</h1>\n\t\t<p>ふと気になったので調べてみました。\n\t\t今までよく無事だったなあ。。\n\t\t単語としては、以下のとおり。</p>\n\t\t<dl>\n\t\t<div>\n\t\t\t<dt>Cache-WORM</dt>\n\t\t\t<dd>キャッシュとWORMのセットになったディスク</dd>\n\t\t</div>\n\t\t<div>\n\t\t\t<dt>Cache</dt>\n\t\t\t<dd>Cache-WORMディスクのCache部分</dd>\n\t\t</div>\n\t\t<div>\n\t\t\t<dt>WORM</dt>\n\t\t\t<dd>Cache-WORMディスクのWORM部分</dd>\n\t\t</div>\n\t\t</dl>\n\t\t<section>\n\t\t\t<h2>Cacheが壊れたとき</h2>\n\t\t\t<p>たぶん、filsysを再設定して、recover mainで復旧。\n\t\t\tとりあえずディスクタイプを先にまとめ。</p>\n\t\t\t<pre><code>dev-&gt;type:\n\t'(' =&gt; Devcat\n\t'[' =&gt; Devmlev\n\t'{' =&gt; Devmirr\n\t'c' =&gt; Devcw\n\t'w' =&gt; Devwren\n\t'f' =&gt; Devfworm\n\t'p' =&gt; Devpart\n\t'x' =&gt; Devswab\n\t'n' =&gt; Devnone\t\t# 特別なデバイス</code></pre>\n\t\t</section>\n\t\t<section>\n\t\t\t<h2>例題</h2>\n\t\t\t<p>以下のデバイス式の場合。</p>\n\t\t\t<pre><code>cw0f{w1w2}</code></pre>\n\t\t\t<p>およそ次のようなデータ構造になる。</p>\n\t\t\t<pre><code>d-&gt;type = Devcw\nd-&gt;cw.c = {\n\ttype = Devwren\n}\nd-&gt;cw.w = {\n\ttype = Devfworm\n\tfw.fw = {\n\t\ttype = Devmirr\n\t\tcat = w1{type = Devwren} :: w2{type = Devwren}\n\t}\n}\nd-&gt;cw.ro = {\t\t# filsys * oで使う; /2010/0705とかを格納する\n\ttype = Devro\n\tro-&gt;parent = d\n}</code></pre>\n\t\t\t<p>これをふまえて、recoverの処理を追ってみた。</p>\n\t\t\t<section>\n\t\t\t\t<h3>arginit</h3>\n\t\t\t\t<pre><code class=\"c\">fs-&gt;flags |= FRECOVER</code></pre>\n\t\t\t\t<p>後の処理で使うためのフラグ立て。\n\t\t\t\trecoverコマンドはconfigモードを抜けてはじめて処理される。</p>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>sysinit</h3>\n\t\t\t\t<pre><code class=\"c\">fs-&gt;dev = iconfig(fs-&gt;config)\nif(fs-&gt;flags&amp;FRECOVER)\n\tdevrecover(fs-&gt;dev)</code></pre>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>devrecover(dev)</h3>\n\t\t\t\t<pre><code class=\"c\">cwrecover(dev)</code></pre>\n\t\t\t\t<p>どんどん深くなる。。\n\t\t\t\tここで、cwrecoverに渡されるdevは、\n\t\t\t\tCache-WORMディスクだけになっている。</p>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>cwrecover(dev)</h3>\n\t\t\t\t<p>WORMのSuperblockを取ってきたりいろいろ。これが肝っぽい。\n\t\t\t\tWORMのSuperblockを渡り歩いて、\n\t\t\t\t最新ならそれのアドレスをbaddrにセットしておく。\n\t\t\t\tこれは、最初のSuperblockは固定アドレスにあるが、\n\t\t\t\t以降は可変のため。</p>\n\t\t\t\t<p>で、最新のSuperblock(言い換えると最終dump)が定まると、\n\t\t\t\t続けて各種ブロックアドレスをCacheに設定。</p>\n\t\t\t\t<pre><code class=\"c\">p = getbuf(wdev, baddr, Bread)\ns = (Superb*)p-&gt;iobuf\ncb = cacheinit(dev)\t\t# 初期化するだけ\nh = (Cache*)cb-&gt;iobuf\nh-&gt;sbaddr = baddr\nh-&gt;cwraddr = s-&gt;cwraddr</code></pre>\n\t\t\t\t<p>一部省略したけど、これで終わりっぽい。\n\t\t\t\tざっと調べると、Cacheは本当にただのキャッシュで、\n\t\t\t\tディスク容量が足りなくなれば、古いキャッシュを一部捨てて、\n\t\t\t\t新しいキャッシュ用に空きを作るらしい。\n\t\t\t\trecover直後はまったくキャッシュされていない状態になるのかな。</p>\n\t\t\t</section>\n\t\t</section>\n\t\t<section>\n\t\t\t<h2>WORMが壊れたとき</h2>\n\t\t\t<p>まだ途中までしか追ってないけど、こっちが壊れたら終わりっぽい。\n\t\t\tなので、最低限ミラーリングしておかないとまずい気がする。\n\t\t\tミラーしているディスクのうち1台でも残っているなら、\n\t\t\tcopydevかcopywormを使えば良さそうな気がするなあ。</p>\n\t\t\t<p>うーん、仮定ばかりだね。あとで調べる。</p>\n\t\t\t<p>もしかして、ディスクを交換したら\n\t\t\t自動でコピーしてくれるのかなと思ったら。</p>\n\t\t\t<section>\n\t\t\t\t<h3>{w1w2}を初期化する流れ</h3>\n\t\t\t\t<pre><code>port/main.c:122: main(void)\nport/config.c:903: arginit(void)\ndev/fworm.c:43: fworminit(Device *d)\nport/sub.c:1389: devinit(Device *d)\ndev/mworm.c:201: mirrinit(Device *d) </code></pre>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>ブロックを読む時</h3>\n\t\t\t\t<pre><code>dev/mworm.c:233: mirrread(Device *d, Off b, void *c)\n\tforで配列分ループして、devread() == 0(正常？)なら抜けてる\nport/sub.c:1096: devread(Device *d, Off b, void *c)\ndev/wren.c:107: wrenread(Device *d, Off b, void *c)\n\tこれらは最終的にはscsiioに帰結してる</code></pre>\n\t\t\t</section>\n\t\t\t<p>ということは、各ミラーの整合性は自分で取れってことかな。</p>\n\t\t</section>\n\t\t<section>\n\t\t\t<h2>Cacheを新しくするとき</h2>\n\t\t\t<p>たぶんキャッシュが壊れたときと同じでrecoverすればいい。</p>\n\t\t</section>\n\t\t<section>\n\t\t\t<h2>WORMを新しくするとき</h2>\n\t\t\t<p>あとで</p>\n\t\t</section>\n\t\t<section>\n\t\t\t<h2>サーバそのものが全壊したとき</h2>\n\t\t\t<p>どうしようね。</p>\n\t\t\t<dl>\n\t\t\t<div>\n\t\t\t\t<dt>CD/DVD</dt>\n\t\t\t\t<dd>700M/4G</dd>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<dt>Blu-ray</dt>\n\t\t\t\t<dd>25G</dd>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<dt>USB HDD</dt>\n\t\t\t\t<dd>500Gから</dd>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<dt>ネットワーク</dt>\n\t\t\t\t<dd>?</dd>\n\t\t\t</div>\n\t\t\t</dl>\n\t\t\t<p>プログラムを書いたりhtml書いたりしているだけなので\n\t\t\tまだそんなに容量使ってないけど、\n\t\t\tさすがに光ディスクは現実的ではないと思う。\n\t\t\tとはいえ、どれにしても、allowしないとだめなんだよなあ。。</p>\n\t\t</section>\n\t</section>\n</main>\n<aside>\n\t<h1>参照ページ</h1>\n\t<ul>\n\t<li><a href=\"http://plan9.aichi-u.ac.jp/fs/\">ファイルシステム</a></li>\n\t</ul>\n</aside>\n<aside>\n\t<h1>やっていること</h1>\n\t<ul>\n\t<li><a href=\"/plan9/index.html\">Plan 9</a></li>\n\t<li><a href=\"http://web.me.com/lufia/alefcompiler/alef/\">Alefコンパイラを読む</a></li>\n\t</ul>\n</aside>\n<footer>\n\t<p>見れない、表示がおかしい場合は、動作環境を添えて<a href=\"mailto:webmaster@lufia.org\">webmaster@lufia.org</a>まで連絡ください。</p>\n</footer>\n</body>\n</html>\n"},"__N_SSG":true}