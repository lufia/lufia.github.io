{"pageProps":{"html":"<!doctype html>\n<html lang=\"ja\">\n<head>\n<meta charset=\"utf-8\">\n<title>orange/note: SproutCoreでデータベースと接続</title>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n<meta name=\"author\" content=\"http://www.hatena.ne.jp/lufiabb/\">\n</head>\n<body>\n<nav>\n\t<h1>メニュー</h1>\n\t<ul>\n\t<li><a href=\"/notes/index.html\">orange/note</a></li>\n\t<li><a href=\"/notes/pc.html\">PC関連</a></li>\n\t<li><a href=\"/notes/web.html\">web製作</a></li>\n\t<li><a href=\"/notes/sec.html\">セキュリティ</a></li>\n\t<li><a href=\"/notes/hobby.html\">本・ゲーム</a></li>\n\t<li><a href=\"/notes/junk.html\">ジャンク</a></li>\n\t</ul>\n</nav>\n<main>\n\t<p class=\"revision\">2011年2月26日更新</p>\n\t<section>\n\t\t<h1>SproutCoreでデータベースと接続</h1>\n\t\t<section>\n\t\t\t<h2>データソースの作成</h2>\n\t\t\t<pre><code class=\"console\">$ sc-gen data-source Blog.articleDataSource</code></pre>\n\t\t\t<p>data_sourcesにファイルが生成されます。\n\t\t\t以下のうち必要な関数を書き換えるといいです。</p>\n\t\t\t<dl>\n\t\t\t<div>\n\t\t\t\t<dt>fetch</dt>\n\t\t\t\t<dd>クエリでSC.Store#findした場合などで使われる</dd>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<dt>retrieveRecord</dt>\n\t\t\t\t<dd>IDを使ってSC.Store#findした場合</dd>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<dt>createRecord</dt>\n\t\t\t\t<dd>SC.Store#createRecordしたとき</dd>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<dt>updateReocrd</dt>\n\t\t\t\t<dd>変更</dd>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<dt>destroyRecord</dt>\n\t\t\t\t<dd>削除</dd>\n\t\t\t</div>\n\t\t\t</dl>\n\t\t\t<p>自動更新しない場合は、</p>\n\t\t\t<pre><code class=\"js\">SC.Store.create({ commitRecordsAutomatically: NO }).find(...)</code></pre>\n\t\t</section>\n\t\t<section>\n\t\t\t<h2>ストアキー</h2>\n\t\t\t<p>個々のレコードには、ストア内かな、で一意なIDが割り当てられます。\n\t\t\tこれをストアキーと呼ぶみたいです。\n\t\t\tSC.Record#primaryKeyはモデル別に一意なのですが、\n\t\t\tこちらはモデルが違っても競合することはありません。</p>\n\t\t\t<pre><code class=\"js\">var a = Blog.store.find(Blog.Article, 1)\nvar c = Blog.store.find(Blog.Comment, 1)\na.get('id')\t\t\t// 1\nc.get('id')\t\t\t// 1\na.get('storeKey')\t// 6とか、その都度いろいろ\nc.get('storeKey')\t// 7とか</code></pre>\n\t\t</section>\n\t\t<section>\n\t\t\t<h2>NestedStore</h2>\n\t\t\t<p>NestedStoreは、別ウインドウでOKボタンを押したら\n\t\t\tデータをサーバへ保存する、といった場合によく使います。\n\t\t\tSC.NestedStore#commitChangesで元のストアに反映されて、\n\t\t\t最終的にSC.Store#commitRecordsにより保存です。\n\t\t\tSC.Store#commitRecordsAutomaticallyがYESであっても\n\t\t\tcommitChangesで自動的に反映はしないっぽい。</p>\n\t\t\t<ul>\n\t\t\t<li><a href=\"http://wiki.sproutcore.com/w/page/12412873/DataStore-NestedStores\">DataStore NestedStores</a></li>\n\t\t\t</ul>\n\t\t</section>\n\t\t<section>\n\t\t\t<h2>クエリ</h2>\n\t\t\t<section>\n\t\t\t\t<h3>クエリの種類</h3>\n\t\t\t\t<p>大きく、ローカルクエリとリモートクエリの2種類あります。\n\t\t\t\tリモートクエリはサーバと通信して\n\t\t\t\tデータをメモリに読み込むことを目的としていて、\n\t\t\t\t検索条件や並び替えなどは無視されます。\n\t\t\t\tローカルクエリはメモリに読み込んだデータを扱い、\n\t\t\t\t検索条件や並び替えといった機能が有効になっています。</p>\n\t\t\t\t<p>例外的に、ローカルクエリであっても最初の呼び出し時だけは\n\t\t\t\tサーバと通信してデータをメモリに読み込みます。</p>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>ローカルクエリ</h3>\n\t\t\t\t<p>並び替え</p>\n\t\t\t\t<pre><code class=\"js\">SC.Query.local(Blog.Article, { orderBy: 'createdDate DESC' })</code></pre>\n\t\t\t\t<p>または、パラメータ(SCQL)を使う場合</p>\n\t\t\t\t<pre><code class=\"js\">SC.Query.local(Blog.Comment, 'article = {article}', {\n\tarticle: this\n})</code></pre>\n\t\t\t\t<p>いわゆるwhereとorderbyを同時に設定するクエリを書くには、\n\t\t\t\tSC.Query#localは使えません。以下のようにします。</p>\n\t\t\t\t<pre><code class=\"js\">SC.Query.create({\n\trecordType: Blog.Article,\n\tconditions: 'category={target}',\n\tparameters: { target: value },\n\torderBy: 'createdDate DESC'\n})</code></pre>\n\t\t\t\t<p>また、SC.Query#localと違って、\n\t\t\t\trecordTypeを文字列にできません。</p>\n\t\t\t</section>\n\t\t</section>\n\t\t<section>\n\t\t\t<h2>トラブルシューティング</h2>\n\t\t\t<section>\n\t\t\t\t<h3>SC.Query作成時に型が無いとエラーになる</h3>\n\t\t\t\t<p>型を参照する前にsc_requireを使うと、\n\t\t\t\t回避できるかもしれません。</p>\n\t\t\t\t<pre><code class=\"js\">sc_require('models/article')\nBlog.ARTICLE_QUERY = SC.Query.local('Blog.Article', {\n\torderBy: 'createdDate DESC'\n})</code></pre>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>IEでputすると、HTTPステータスコードが1223で失敗する</h3>\n\t\t\t\t<p>これはIEの不具合で、204を受け取るとなぜか1223となるみたい。\n\t\t\t\tSproutCore 1.4.1ではまだ対応されていないですし、\n\t\t\t\t対応するのかも分かりませんが、\n\t\t\t\tとりあえず以下のコードで回避できます。\n\t\t\t\tちょっと強引ですけどね。</p>\n\t\t\t\t<pre><code class=\"js\">didUpdateRecord: function(r, store, storeKey){\n\tif(SC.ok(r) || (SC.browser.msie &amp;&amp; r.get('status') == 1223)\n\t\t// success\n\telse\n\t\t// error\n}</code></pre>\n\t\t\t\t<p>ちなみに、SC.browser.msieにはバージョンが入っています。\n\t\t\t\tIE8の場合は&quot;8.0&quot;という文字列。</p>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>新規レコードのIDがundefinedになる</h3>\n\t\t\t\t<p>レコード作成時に、SC.Store#dataSourceDidCompleteの\n\t\t\t\t第3引数でIDを設定した場合、データハッシュのIDは変わっていません。\n\t\t\t\tなので、ストアキーからIDを調べる場合は、\n\t\t\t\t常にSC.Store#idForを使ったほうがいいと思います。</p>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>createRecordしたのにデータソースへ処理が移らない</h3>\n\t\t\t\t<p>ストアのcommitRecordsAutomaticallyがNOの場合、\n\t\t\t\tcommitRecordするといいかもしれないです。</p>\n\t\t\t</section>\n\t\t</section>\n\t</section>\n</main>\n<aside>\n\t<ul>\n\t<li><a href=\"1203.html\">SproutCoreのモデル定義</a></li>\n\t<li><a href=\"http://wiki.sproutcore.com/w/page/12413058/Todos%2007-Hooking%20Up%20to%20the%20Backend\">Hooking Up to the Backend</a></li>\n\t</ul>\n</aside>\n<aside>\n\t<h1>やっていること</h1>\n\t<ul>\n\t<li><a href=\"/plan9/index.html\">Plan 9</a></li>\n\t<li><a href=\"http://web.me.com/lufia/alefcompiler/alef/\">Alefコンパイラを読む</a></li>\n\t</ul>\n</aside>\n<footer>\n\t<p>見れない、表示がおかしい場合は、動作環境を添えて<a href=\"mailto:webmaster@lufia.org\">webmaster@lufia.org</a>まで連絡ください。</p>\n</footer>\n</body>\n</html>\n"},"__N_SSG":true}