{"pageProps":{"html":"<!doctype html>\n<html lang=\"ja\">\n<head>\n<meta charset=\"utf-8\">\n<title>orange/note: SproutCoreモデル定義</title>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n<meta name=\"author\" content=\"http://www.hatena.ne.jp/lufiabb/\">\n</head>\n<body>\n<nav>\n\t<h1>メニュー</h1>\n\t<ul>\n\t<li><a href=\"/notes/index.html\">orange/note</a></li>\n\t<li><a href=\"/notes/pc.html\">PC関連</a></li>\n\t<li><a href=\"/notes/web.html\">web製作</a></li>\n\t<li><a href=\"/notes/sec.html\">セキュリティ</a></li>\n\t<li><a href=\"/notes/hobby.html\">本・ゲーム</a></li>\n\t<li><a href=\"/notes/junk.html\">ジャンク</a></li>\n\t</ul>\n</nav>\n<main>\n\t<p class=\"revision\">2011年2月14日更新</p>\n\t<section>\n\t\t<h1>SproutCoreモデル定義</h1>\n\t\t<section>\n\t\t\t<h2>モデルの作成</h2>\n\t\t\t<pre><code class=\"console\">$ sc-gen model Blog.Article</code></pre>\n\t\t\t<p>これで、model/article.jsが生成されます。\n\t\t\tもうひとつテスト用のファイルも作られますが、\n\t\t\tそれについては後日。</p>\n\t\t</section>\n\t\t<section>\n\t\t\t<h2>レコードとデータハッシュ</h2>\n\t\t\t<p>SproutCoreのデータは、だいたい2種類の構成に分かれます。\n\t\t\tひとつは、SC.Recordを拡張したモデル定義部分で、\n\t\t\tもうひとつは実際のデータを持ったオブジェクトです。\n\t\t\t後者はデータハッシュと呼ばれます。</p>\n\t\t\t<p>レコードは内部にデータハッシュを持ち、\n\t\t\tget/setを使ったアクセス時には、関数プロパティを除いて\n\t\t\tほとんどがデータハッシュの値を扱います。\n\t\t\tふつうは、これらの違いを意識する必要はないと思いますが、\n\t\t\t新規レコードの作成やFIXTURESの設定など、直接データハッシュを\n\t\t\t扱う場合がありますので注意です。</p>\n\t\t\t<p>たとえばブログ的なものの記事を定義する場合、</p>\n\t\t\t<pre><code class=\"js\">Blog.Article = SC.Record.extend({\n\tsubject: SC.Record.attr(String, {\n\t\tkey: 'Subject'\n\t}),\n\tcreatedDate: SC.Record.attr(SC.DateTime, {\n\t\tkey: 'CreatedDate'\n\t})\n})</code></pre>\n\t\t\t<p>FIXTURESに設定するオブジェクトは以下のようになります。\n\t\t\t下のほうでも詳しく書きますが、SC.DateTime型のデータハッシュは\n\t\t\t文字列になりますので注意です。</p>\n\t\t\t<pre><code class=\"js\">Blog.Article.FIXTURES = [\n{\tguid: 0,\n\tSubject: 'article1',\n\tCreatedDate: '2010-12-03T00:00:00+09:00'\n},\n{\tguid: 1,\n\tSubject: 'article2',\n\tCreatedDate: '2010-12-14T00:00:00+09:00'\n}\n]</code></pre>\n\t\t\t<p>同様に、SC.Store#createRecordの第2引数もデータハッシュです。</p>\n\t\t</section>\n\t\t<section>\n\t\t\t<h2>主キーのカラム名</h2>\n\t\t\t<p>主キーのカラム名を変更する場合は、\n\t\t\t次に書くSC.Record.attrのkeyオプションを使うのではなくて、\n\t\t\t特別にSC.Record#primaryKeyプロパティを設定します。</p>\n\t\t\t<pre><code>Blog.Article = SC.Record.extend({\n\tprimaryKey: 'ID',\n\t...</code></pre>\n\t\t\t<p>この場合に、article.get('id')はデータハッシュのIDを返しますが、\n\t\t\tarticle.get('guid')はundefinedになります。\n\t\t\t特別な理由が無い限り、常にget('id')を使ったほうが無難です。</p>\n\t\t</section>\n\t\t<section>\n\t\t\t<h2>SC.Record.attrのオプション</h2>\n\t\t\t<p>上のほうでもkeyオプションを使っていますが、\n\t\t\tSC.Record.attr()の第2引数にはオプションオブジェクトを渡せます。\n\t\t\tここで使えるオプションは以下になります。</p>\n\t\t\t<dl>\n\t\t\t<div>\n\t\t\t\t<dt>isRequired</dt>\n\t\t\t\t<dd>必須ならYES</dd>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<dt>key</dt>\n\t\t\t\t<dd>対応するテーブルのカラム名</dd>\n\t\t\t\t<dd>指定しなければ同名</dd>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<dt>defaultValue</dt>\n\t\t\t\t<dd>デフォルト値</dd>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<dt>format</dt>\n\t\t\t\t<dd>型がSC.DateTimeの場合のみ有効</dd>\n\t\t\t\t<dd>get/set時に、この書式を使ってparseやtoFormattedStringを呼び出す</dd>\n\t\t\t\t<dd>指定しなければ'%Y-%m-%dT%H:%M:%S%Z'</dd>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<dt>useIsoDate</dt>\n\t\t\t\t<dd>型がDateの場合のみ有効で、初期値はYES</dd>\n\t\t\t\t<dd>用途としてはformatと同じ</dd>\n\t\t\t</div>\n\t\t\t</dl>\n\t\t\t<p>最後のformatとuseIsoDateは分かりにくいですが、\n\t\t\tデータハッシュとモデルの間で変換するために使われるだけです。\n\t\t\tgetするとその書式で文字列が返ってくるわけではありません。\n\t\t\tなので、SC.TextFieldViewなどに書式を指定してバインドする場合は、\n\t\t\tこれとは別にSC.Binding#dateTimeを使います。</p>\n\t\t</section>\n\t\t<section>\n\t\t\t<h2>実験</h2>\n\t\t\t<pre><code class=\"js\">data.set('createdDate', SC.DateTime.create({\n\tyear: 2010, month: 12, day: 14, hour: 0\n})\n// 特別に、こっちでも同じ\n//data.set('createdDate', '2010-12-14T00:00:00+09:00')\n\n// もちろん設定した値は同じ\nequals(data.get('createdDate'), SC.DateTime.create({...}))\n\n// データハッシュは文字列型\nvar p = Blog.store.readDataHash(data.get('storeKey'))\nequals(p.CreatedDate, '2010-12-14T00:00:00+09:00')</code></pre>\n\t\t\t<div class=\"note\">\n\t\t\t\t<p>SC.DateTimeは、年月日しか明示的に指定しなかった場合、\n\t\t\t\t時刻部分を現在時刻で設定します。\n\t\t\t\tこれはSC.DateTime.parseでも同じ動きをして、\n\t\t\t\t以下の場合も現在時刻が設定されます。</p>\n\t\t\t\t<pre><code>var d = SC.DateTime.parse('2010-12-01', '%Y-%m-%d')</code></pre>\n\t\t\t\t<p>時刻を0:00:00で初期化したい場合は、時間に0を設定します。</p>\n\t\t\t\t<pre><code>var d = SC.DateTime.parse('2010-12-01T00', '%Y-%m-%dT%H')\n\n// 以下でも同じ\nd = SC.DateTime.parse('2010-12-01', '%Y-%m-%d')\n\t.adjust({ hour: 0 })</code></pre>\n\t\t\t</div>\n\t\t</section>\n\t\t<section>\n\t\t\t<h2>DateTime型変換</h2>\n\t\t\t<p>上でも書いたように、SC.DateTime型のプロパティは\n\t\t\tデータハッシュに文字列として保存されます。\n\t\t\tこれは、アプリケーション全体に適用される、\n\t\t\t型とデータハッシュの変換ルールに設定されているからです。\n\t\t\t通常これで困ることはありませんが、独自にルールを設定したい場合とか、\n\t\t\tこれが悪さをする場合には、SC.RecordAttribute.registerTransformで\n\t\t\t別のルールに差し替えられるようになっています。\n\t\t\tregisterTransformは対象の型と変換オブジェクトを引数に取ります。</p>\n\t\t\t<p class=\"note\">SC.DateTimeに限らず、NumberやDateも\n\t\t\tあらかじめ変換ルールが設定されています。</p>\n\t\t\t<p>使い方は以下のような感じ。\n\t\t\tこの例では、データハッシュをDateにさせています。\n\t\t\t個人的にmain.jsの先頭が定位置。</p>\n\t\t\t<pre><code class=\"js\">SC.RecordAttribute.registerTransform(SC.DateTime, {\n\tto: function(d, attr){\n\t\tif(SC.none(d))\n\t\t\treturn null\n\t\treturn SC.DateTime.create(d.valueOf())\n\t},\n\tfrom: function(s, attr){\n\t\tif(SC.none(s) || s === '')\n\t\t\treturn null\n\t\telse if(SC.instanceOf(s, SC.DateTime))\n\t\t\treturn new Date(s.get('milliseconds'))\n\t\telse\n\t\t\treturn new Date(s.valueOf())\n\t}\n})</code></pre>\n\t\t\t<p>from関数はレコードのset呼び出し時に使われ、to関数は逆です。\n\t\t\tこれらは第1引数に設定する値(またはデータハッシュの値)、\n\t\t\t第2引数にモデルのSC.Record.attrで設定したオブジェクトを取ります。\n\t\t\tsetはtoを使わないでvalueをそのまま返しますので、\n\t\t\t動作テストするときには注意です。</p>\n\t\t\t<pre><code class=\"js\">// set('key', value)の時(だいたいこんな感じ)\nhash[key] = from(value)\nreturn value\n\n// get('key')の時(だいたいこんな感じ)\nreturn to(hash[key])</code></pre>\n\t\t</section>\n\t\t<section>\n\t\t\t<h2>関数プロパティ</h2>\n\t\t\t<p>英語でcomputed propertyですが、うまい訳を思いつかなかったので。</p>\n\t\t\t<pre><code class=\"js\">createdYear: function(){\n\treturn this.getPath('createdDate.year')\n}.property('createdDate').cacheable()</code></pre>\n\t\t\t<p>ここで、Function#propertyに渡す引数は、\n\t\t\t計算するときに依存するプロパティの名前です。\n\t\t\t複数のプロパティに依存する場合は、第2引数、第3引数と、\n\t\t\t必要なだけプロパティ名を渡します。\n\t\t\tレコードのプロパティ名で、データハッシュではありません。\n\t\t\t上記の場合、createdDateに対してsetを呼び出すと、\n\t\t\tcreatedYearが更新されたことを、\n\t\t\tこれに依存しているオブジェクトへ通知します。</p>\n\t\t</section>\n\t\t<section>\n\t\t\t<h2>リレーションシップ</h2>\n\t\t\t<p>たとえば記事とコメントの関係は、\n\t\t\tモデルで定義すると以下のようになります。\n\t\t\t必要な部分だけ抜粋しつつ、まずは記事テーブルの一部。</p>\n\t\t\t<table>\n\t\t\t<tr><th>列名</th><th>型っぽいもの</th></tr>\n\t\t\t<tr><td>ID</td><td>主キー</td></tr>\n\t\t\t<tr><td>Subject</td><td>文字列</td></tr>\n\t\t\t<tr><td>CreatedDate</td><td>日付</td></tr>\n\t\t\t</table>\n\t\t\t<p>コメントのほうはこちら。</p>\n\t\t\t<table>\n\t\t\t<tr><th>列名</th><th>型っぽいもの</th></tr>\n\t\t\t<tr><td>ID</td><td>主キー</td></tr>\n\t\t\t<tr><td>ArticleID</td><td>外部キー</td></tr>\n\t\t\t<tr><td>Message</td><td>文字列</td></tr>\n\t\t\t</table>\n\t\t\t<p>で、モデル定義。</p>\n\t\t\t<pre><code class=\"js\">Blog.Article = SC.Record.extend({\n\tprimaryKey: 'ID',\n\tsubject: SC.Record.attr(String, {key: 'Subject'}),\n\tcreatedDate: SC.Record.attr(SC.DateTime, {key: 'CreatedDate'}),\n\tcomments: SC.Record.toMany('Blog.Comment', {\n\t\tinverse: 'article',\n\t\tisMaster: NO\n\t})\n})\nBlog.Comment = SC.Record.extend({\n\tprimaryKey: 'ID',\n\tmessage: SC.Record.attr(String, {key: 'Message'}),\n\tarticle: SC.Record.toOne('Blog.Article', {\n\t\tkey: 'ArticleID',\n\t\tinverse: 'comments',\n\t\tisMaster: YES\n\t})\n})</code></pre>\n\t\t\t<p>何がどう対応するかは、なんとなく分かるかなあと思います。</p>\n\t\t\t<p>ちょっと不思議なものはisMasterオプションで、\n\t\t\tこれは、リレーションの変更があった場合に\n\t\t\tどちらのデータを更新するかを指示するものです。</p>\n\t\t\t<pre><code class=\"js\">var article = getArticle()\nvar comment = SC.store.createRecord(Blog.Comment, {\n\tMessage: '...',\n})\ncomment.set('postedDate', SC.DateTime.create())\ncomment.set('article', article)</code></pre>\n\t\t</section>\n\t\t<section>\n\t\t\t<h2>モデルへのデータ格納</h2>\n\t\t\t<p>サーバにないデータをモデルに格納したい場合。\n\t\t\tたとえば固定的なメニューを作りたい時は、\n\t\t\tSC.Store#loadRecordまたはloadRecordsを使うといいです。\n\t\t\tこれはデータハッシュを受け付けますので、\n\t\t\tそこに作成したいモデル用のデータを渡します。</p>\n\t\t</section>\n\t\t<section>\n\t\t\t<h2>オートナンバーなキーの場合</h2>\n\t\t\t<p>作成時はnullにしておいて、データソースの\n\t\t\tcreateRecord時に取得したロケーションなどを使って設定するっぽい。\n\t\t\t詳細は<a href=\"1225.html\">データストアまとめ</a>のほうで書きます。</p>\n\t\t</section>\n\t\t<section>\n\t\t\t<h2>トラブルシューティング</h2>\n\t\t\t<section>\n\t\t\t\t<h3>何も変更していないのにBUSY_COMMITTING</h3>\n\t\t\t\t<p>データストアと関連しての症状ですが、\n\t\t\t\tデータベースのデータを読み込んだだけで、\n\t\t\t\t各レコードのステータスがBUSY_COMMITTINGになる場合。</p>\n\t\t\t\t<p>これは、SC.Record#writeAttributeを\n\t\t\t\t関数プロパティの中で使っていたのですが、\n\t\t\t\tたとえモデルに定義していないプロパティへ書き込んだとしても、\n\t\t\t\t何かを書き込んだ時点で「変更あり」扱いになるのが原因でした。</p>\n\t\t\t\t<p>ちなみに、レコードのステータスは、\n\t\t\t\tSC.Store#statusStringを使うと分かりやすくていいです。</p>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>SC.DateTimeをTextFieldViewにバインドして編集するとエラー</h3>\n\t\t\t\t<pre><code class=\"js\">valueBinding: SC.Binding\n\t.from('Blog.articleController.createdDate')\n\t.dateTime('%Y/%m/%d')</code></pre>\n\t\t\t\t<p>これを編集可能にして、実際に編集すると、\n\t\t\t\t「オブジェクトでサポートされていないプロパティまたはメソッドです」\n\t\t\t\tというエラーで終了します。</p>\n\t\t\t\t<p>これは、SproutCoreの仕様なのかバグなのか、\n\t\t\t\tはたまた使い方が間違っているのか知りませんが、\n\t\t\t\tSC.Binding#dateTimeはSC.DateTime型を想定しています。\n\t\t\t\tでも編集後の型は文字列になっているので、\n\t\t\t\tString#toFormattedStringを呼び出そうとして落ちているみたいです。</p>\n\t\t\t\t<p>同様に、デフォルトでregisterTransformされている関数も、\n\t\t\t\tString#toFormattedStringを呼び出そうとしてエラーになります。\n\t\t\t\tなので、この2点に修正が必要です。</p>\n\t\t\t\t<pre><code class=\"js\">function getFormat(attr)\n{\n\treturn attr.get('format') || SC.DateTime.recordFormat\n}\nSC.RecordAttribute.registerTransform(SC.DateTime, {\n\tto: function(d, attr){\n\t\tif(SC.none(d))\n\t\t\treturn null\n\t\tvar fmt = getFormat(attr)\n\t\treturn SC.DateTime.parse(d, fmt)\n\t},\n\tfrom: function(s, attr){\n\t\tif(SC.none(s) || s === '')\n\t\t\treturn null\n\t\tif(!SC.instanceOf(s, SC.DateTime))\n\t\t\ts = SC.DateTime.create({\n\t\t\t\tmilliseconds: new Date(s).valueOf()\n\t\t\t})\n\t\tvar fmt = getFormat(attr)\n\t\treturn s.toFormattedString(fmt)\n\t}\n})\n\nBlog.dateTimeValidator = SC.Validator.extend({\n\tformat: null,\n\n\tvalidate: function(form, field){\n\t\tvar value = field.get('fieldValue')\n\t\treturn value ==='' || !!SC.DateTime.parse(value, this.get('format'))\n\t},\n\n\tvalidateError: function(form, field){\n\t\tvar label = field.get('errorLabel') || 'Field'\n\t\treturn SC.$error('invalid date'.loc(), label)\n\t}\n})\n\nBlog.DateTimeBinding = SC.Binding\n\t.transform(function(d){\n\t\tif(SC.instanceOf(d, SC.DateTime))\n\t\t\treturn d.toFormattedString('%Y/%m/%d')\n\t\treturn d\t\t\t\t\n\t})\n\nBlog.mainPage = SC.Page.design({\n\t...\n\tcreatedDateView: SC.LabelView.design({\n\t\tisEditable: YES,\n\t\tvalueBinding: Blog.DateTimeBinding\n\t\t\t.beget('Blog.articleController.createdDate'),\n\t\tvalidator: Blog.dateTimeValidator.create({\n\t\t\tformat: '%Y/%m/%d'\n\t\t})\n\t}),\n\t...\n})</code></pre>\n\t\t\t\t<p>ここでは、空文字列のときはnullに変換しています。\n\t\t\t\tvalidatorは無くてもいいけど、あったほうが親切。</p>\n\t\t\t\t<p>ほかは、バインド用のプロパティを介して\n\t\t\t\tやりとりするという方法もあります。\n\t\t\t\t個数が少ないなら、こちらのほうが楽かもしれません。</p>\n\t\t\t\t<pre><code class=\"js\">targetDate: function(key, value){\n\tvar fmt = '%Y-%m-%d'.loc()\n\tif(!SC.none(value)){\n\t\ttry{\n\t\t\tvar newp = SC.DateTime\n\t\t\t\t.parse(value, fmt)\n\t\t\t\t.adjust({ hour: 0 })\n\t\t\tthis.set('date', newp)\n\t\t}catch(e){\n\t\t\t// 無視する\n\t\t}\n\t}\n\tvar p = this.get('date')\n\treturn p &amp;&amp; p.toFormattedString(fmt)\n}.property('date').cacheable(),</code></pre>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>DateTimeBindingが1つを除いて空欄になる</h3>\n\t\t\t\t<p>上のトラブルシューティングに関連して。</p>\n\t\t\t\t<p>SC.Binding#fromは必要なければインスタンスを作りませんので、\n\t\t\t\tBlog.DateTimeBindingでbegetをfromに変えると、\n\t\t\t\t最後のものしか有効になりません。</p>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>バインドした値が更新されない</h3>\n\t\t\t\t<p>モデルだけでテストしようとすると、\n\t\t\t\tバインドした値が更新されなかったりします。\n\t\t\t\tいろいろ端折るとこんな感じ。</p>\n\t\t\t\t<pre><code class=\"js\">var A = SC.Object.create({ name: 'aaa' })\nvar B = SC.Object.create({ nameBinding: 'A.name' })\nA.set('name', 'test')\n// B.get('name') == undefined\nSC.RunLoop.begin()\nSC.RunLoop.end()\n// B.get('name') == 'test'\nB.set('name', 'aaa')\n// A.get('name') == 'test'</code></pre>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>loadRecordsで複数作成したのに1つしかない</h3>\n\t\t\t\t<p>これはたぶん、primaryKeyとなるプロパティが無いからです。</p>\n\t\t\t</section>\n\t\t</section>\n\t</section>\n</main>\n<aside>\n\t<section>\n\t\t<h1>関連情報</h1>\n\t\t<ul>\n\t\t<li><a href=\"http://lufia.org/notes/2010/1129.html\">WCF Data Servicesメモ</a></li>\n\t\t</ul>\n\t</section>\n\t<section>\n\t\t<h1>参考サイト</h1>\n\t\t<ul>\n\t\t<li><a href=\"http://wiki.sproutcore.com/w/page/28716312/Showing-a-relation-as-selection-on-a-list-view\">Showing a relation as selection on a list view</a></li>\n\t\t<li><a href=\"http://wiki.sproutcore.com/w/page/12412887/DateTime\">DateTime</a></li>\n\t\t</ul>\n\t</section>\n</aside>\n<aside>\n\t<h1>やっていること</h1>\n\t<ul>\n\t<li><a href=\"/plan9/index.html\">Plan 9</a></li>\n\t<li><a href=\"http://web.me.com/lufia/alefcompiler/alef/\">Alefコンパイラを読む</a></li>\n\t</ul>\n</aside>\n<footer>\n\t<p>見れない、表示がおかしい場合は、動作環境を添えて<a href=\"mailto:webmaster@lufia.org\">webmaster@lufia.org</a>まで連絡ください。</p>\n</footer>\n</body>\n</html>\n"},"__N_SSG":true}