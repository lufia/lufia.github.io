{"pageProps":{"html":"<!doctype html>\n<html lang=\"ja\">\n<head>\n<meta charset=\"utf-8\">\n<title>orange/note: ファイルサーバのディスクレイアウト</title>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n<meta name=\"author\" content=\"http://www.hatena.ne.jp/lufiabb/\">\n</head>\n<body>\n<nav>\n\t<h1>メニュー</h1>\n\t<ul>\n\t<li><a href=\"/notes/index.html\">orange/note</a></li>\n\t<li><a href=\"/notes/pc.html\">PC関連</a></li>\n\t<li><a href=\"/notes/web.html\">web製作</a></li>\n\t<li><a href=\"/notes/sec.html\">セキュリティ</a></li>\n\t<li><a href=\"/notes/hobby.html\">本・ゲーム</a></li>\n\t<li><a href=\"/notes/junk.html\">ジャンク</a></li>\n\t</ul>\n</nav>\n<main>\n\t<p class=\"revision\">2011年5月13日更新</p>\n\t<section>\n\t\t<h1>ファイルサーバのディスクレイアウト</h1>\n\t\t<section>\n\t\t\t<h2>キャッシュディスク</h2>\n\t\t\t<p>キャッシュディスクは、ディスクの構成、\n\t\t\tデータブロックとWORMアドレスをマップする領域、\n\t\t\tデータ領域の3つに大きく分かれます。</p>\n\t\t\t<p>マップ領域とデータ領域の容量は、\n\t\t\tディスク全体容量によって自動的に構成されます。\n\t\t\tそれを実際に計算しているのはcacheinit()関数。</p>\n\t\t\t<figure>\n\t\t\t\t<img src=\"04282.png\" alt=\"キャッシュディスクのレイアウト\">\n\t\t\t\t<figcaption>キャッシュディスクのレイアウト</figcaption>\n\t\t\t</figure>\n\t\t\t<pre><code>0:\n1:\n2: Cacheな情報が入っている; cacheinit()で設定\n3..M: マップ管理領域; Mはcaddr-1で、だいたいmaddr+msize/BKPERBLK\nN...: データ領域; Nはcaddrで、あとはだらだら続く</code></pre>\n\t\t\t<p class=\"note\">インデックス領域のタグはTbuck</p>\n\t\t\t<p>Limbo風に書くと、ざっくりこんな雰囲気。</p>\n\t\t\t<pre><code class=\"c\">CacheDisk: dt\n{\n\th: Cache;\n\tmap: array[M] of array[BKPERBLK] of array[CEPERBK] of Centry;\n\tblock: array[M*BKPERBLK*CEPERBK] of Block;\n\n\tget: fn(addr: big): ref Iobuf;\n}</code></pre>\n\t\t\t<p>マップアルゴリズムは、対象となるWORMアドレスのハッシュを取り、\n\t\t\tそのハッシュでマップ領域のブロックとBucketインデックスを決定します。\n\t\t\t次に、Bucketのなかをみて、空いているCentryを探します。\n\t\t\tCentryが定まれば、対応するデータ領域のアドレスは\n\t\t\t単純な式で計算できます。いろいろ省略してこんな感じ。</p>\n\t\t\t<pre><code class=\"c\">h = (Cache*)getbuf(cw-&gt;cdev, CACHE_ADDR);\nbn = addr % h-&gt;msize;\t\t\t// Bucketインデックス\na1 = h-&gt;maddr + bn/BKPERBLK;\t\t// Bucketが格納されているアドレス\np = (Bucket*)getbuf(cw-&gt;cdev, a1)-&gt;iobuf;\nb = &amp;p[bn%BKPERBLK];\nc = getcentry(b, addr);\na2 = bn*CEPERBK + h-&gt;caddr;\t\t// addrのデータ領域ブロックアドレス\na2 += c - b-&gt;entry;\t\t\t// オフセットを加算して一意に\ndata = getbuf(cw-&gt;cdev, a2);</code></pre>\n\t\t</section>\n\t\t<section>\n\t\t\t<h2>WORMディスク</h2>\n\t\t\t<section>\n\t\t\t\t<h3>ディレクトリレイアウト</h3>\n\t\t\t\t<figure>\n\t\t\t\t\t<img src=\"04282-3.png\" alt=\"一般的なファイル図\">\n\t\t\t\t\t<figcaption>一般的なファイル図</figcaption>\n\t\t\t\t</figure>\n\t\t\t\t<p>図は、一般的なファイル1つ(Dentry[2])を表現したものです。\n\t\t\t\tこのあたりはほとんどUNIXファイルシステムと同じみたい。\n\t\t\t\tこの図で、Dentry[2]がファイルの場合、\n\t\t\t\tBlock[4]とBlock[7]にはファイルの内容が格納されています。\n\t\t\t\tまたは、Dentry[2]がディレクトリの場合、\n\t\t\t\t上図と同様にDentryの束が格納されます。\n\t\t\t\tブロック中のDentry数は決まっているので、\n\t\t\t\t途中でブロックをまたがることはありません。</p>\n\t\t\t\t<p>Dentry[2]を削除すると、そのブロックから\n\t\t\t\tDALLOCフラグが消えて未割当てな状態になります。\n\t\t\t\t空きができますが、そのままです。詰めません。</p>\n\t\t\t\t<p class=\"note\">ブロックレイアウトからみれば、\n\t\t\t\tディレクトリの途中で空きができますが、\n\t\t\t\t9pで読むときに、f_read関数が空きを見せないようになっています。</p>\n\t\t\t\t<p>Dentryの左下にある数字はslotと呼ばれます。\n\t\t\t\tこれは、ブロック中の何個目にあるエントリかを表します。\n\t\t\t\t複数ブロックにまたがるほど大きなディレクトリの場合では、\n\t\t\t\t次のブロックになるとまた0からはじまります。</p>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>最初の状態</h3>\n\t\t\t\t<p>以下はream後のWORMレイアウト。</p>\n\t\t\t\t<pre><code class=\"c\">0:\n1:\n2: super addr(tag:Tsuper, state=Cdump)\n@Superb{\n\tlast = 2,\n\tcwraddr = 3,\n\troraddr = 4,\n\tnext = 5,\n\tfstart = 2,\n\tfsize = 6,\n\tfbuf = { nfree = 1, free = [0] }\n}\n3: cw root(tag:Tdir, state=Cdump)\n@array[DIRPERBUF] of Dentry {\n[0]\tname = &quot;/&quot;,\n\tslot = 0\n}\n4: ro root(tag:Tdir, state=Cdump)\n@array[DIRPERBUF] of Dentry {\n[0]\tname = &quot;/&quot;,\n\tslot = 0\n}\n5: next sb</code></pre>\n\t\t\t\t<p>頭に@がついているものは、\n\t\t\t\tキャッシュのみ変更があったということです。\n\t\t\t\tなので、この時点ではWORMには何も書き込まれていない。</p>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>初回dump</h3>\n\t\t\t\t<p>これは朝5:00の定期dumpではなく、ream直後に起こります。</p>\n\t\t\t\t<pre><code class=\"c\">0:\n1:\n2: super addr(tag:Tsuper, state=Cread)\nSuperb{\n\tlast = 2,\n\tcwraddr = 3,\n\troraddr = 4,\n\tnext = 5,\n\tfstart = 2,\n\tfsize = 6,\n\tfbuf = { nfree = 1, free = [0] }\n}\n3: cw root(tag:Tdir, state=Cread)\narray[DIRPERBUF] of Dentry {\n[0]\tname = &quot;/&quot;,\n\tslot = 0\n}\n4: ro root(tag:Tdir, state=Cread)\narray[DIRPERBUF] of Dentry {\n[0]\tname = &quot;/&quot;,\n\tslot = 0\n}\n5: next sb</code></pre>\n\t\t\t\t<figure>\n\t\t\t\t\t<img src=\"04282-1.png\" alt=\"WORMのレイアウト\">\n\t\t\t\t\t<figcaption>WORMのレイアウト</figcaption>\n\t\t\t\t</figure>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>WORMディスクの伸長</h3>\n\t\t\t\t<p>最初は小さいディスク(6ブロック)です。</p>\n\t\t\t\t<p>新しいブロックが使われるときはフリーリストから取ります。\n\t\t\t\tフリーリストがなくなればディスクのまとめて伸ばし、\n\t\t\t\t伸びただけフリーリストを確保します。\n\t\t\t\tまた、既存のブロックが更新された場合は、\n\t\t\t\tdumpの際にディスクを1ブロックだけ伸ばして割り当てます。\n\t\t\t\tこのとき、フリーリストが残っていても使いません。\n\t\t\t\t使用状況に応じて、WORMディスクを拡張(grow)します。</p>\n\t\t\t\t<p>ファイルを削除すると、そのブロックはフリーリストに戻ります。\n\t\t\t\tメモ: Cdirtyの場合だけ?</p>\n\t\t\t\t<p class=\"note\">上で、freeの先頭に0が入っているのは、\n\t\t\t\t残り0でアドレスが0なら空き無しと判断しgrowするためみたい。</p>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>ファイルの作成</h3>\n\t\t\t\t<p>create /adm/usersすると、新しいブロックが割り当てられて\n\t\t\t\tファイルが作られます。空きがなければgrowが起こります。\n\t\t\t\t以下はgrowした後、/adm/usersを作り終わった場合。</p>\n\t\t\t\t<pre><code class=\"c\">0:\n1:\n2: super addr(tag:Tsuper, state=Cwrite)\n@Superb{\n\tlast = 2,\n\tcwraddr = 3,\n\troraddr = 4,\n\tnext = 5,\n\tfstart = 2,\n\tfsize = 106,\n\tfbuf = { nfree = 99, free = [0,105,104...8] }\n}\n3: cw root(tag:Tdir, state=Cwrite)\n@array[DIRPERBUF] of Dentry {\n[0]\tname = &quot;/&quot;,\n\tslot = 0,\n\tdblock = [6]\n}\n4: ro root(tag:Tdir, state=Cread)\narray[DIRPERBUF] of Dentry {\n[0]\tname = &quot;/&quot;,\n\tslot = 0\n}\n5: next sb\n6: /(tag:Tdir, state=Cdirty)\n@array[] of Dentry{\n[0]\tname = &quot;adm&quot;,\n\tslot = 0\n\tdblock = [7]\n}\n7: adm(tag:Tfile, state=Cdirty)\n@array[] of Dentry{\n[0]\tname = &quot;users&quot;,\n\tslot = 0\n}</code></pre>\n\t\t\t\t<div class=\"note\">\n\t\t\t\t\t<pre><code class=\"console\">create /adm adm adm 755 d</code></pre>\n\t\t\t\t\t<p>このときのコールフロー。</p>\n\t\t\t\t\t<pre><code class=\"c\">con_create(FID2, &quot;adm&quot;, -1, -1, PDIR&amp;0755, 0)\ncall9p1[Tcreate](message)\nf_create()\ndnodebuf()\nrel2abs()</code></pre>\n\t\t\t\t\t<p>dnodebufのなかで呼び出されるrel2absは、\n\t\t\t\t\tn個目のブロック番号を実際のアドレスへ変換し、\n\t\t\t\t\tそのバッファを返す。\n\t\t\t\t\tNDBLOCK以上なら間接ブロックのどこか。\n\t\t\t\t\tnが未確保なブロックなら\n\t\t\t\t\tbufalloc()でフリーブロックを後ろから確保。</p>\n\t\t\t\t</div>\n\t\t\t\t<p>そのままdumpすると、WORMに書き込まれる対象となります。\n\t\t\t\tここで、前回のdump時に書き込まれたブロックは\n\t\t\t\t変更されていない点に注意です。</p>\n\t\t\t\t<pre><code class=\"c\">0:\n1:\n2: super addr(tag:Tsuper, state=Cread)\nSuperb{\n\tlast = 2,\n\tcwraddr = 3,\n\troraddr = 4,\n\tnext = 5,\n\tfstart = 2,\n\tfsize = 6,\n\tfbuf = { nfree = 1, free = [0] }\n}\n3: cw root(tag:Tdir, state=Cread)\narray[DIRPERBUF] of Dentry {\n[0]\tname = &quot;/&quot;,\n\tslot = 0\n}\n4: ro root(tag:Tdir, state=Cread)\narray[DIRPERBUF] of Dentry {\n[0]\tname = &quot;/&quot;,\n\tslot = 0\n}\n5: super addr(tag:Tsuper, state=Cdump, ver2)\n@Superb{\n\tlast = 2,\n\tcwraddr = 106,\n\troraddr = 107,\n\tnext = 108,\n\tfstart = 2,\n\tfsize = 109,\n\tfbuf = { nfree = 97, free = [0,105,104...10] }\n}\n6: /(tag:Tdir, state=Cdump)\n@array[] of Dentry{\n[0]\tname = &quot;adm&quot;,\n\tslot = 0\n\tdblock = [7]\n}\n7: adm(tag:Tfile, state=Cdump)\n@array[] of Dentry{\n[0]\tname = &quot;users&quot;,\n\tslot = 0\n}\n8: /(ro)(tag:Tdir, state=Cdump)\n@array[] of Dentry {\n[0]\tname = &quot;2011&quot;\n\tslot = 0\n\tdblock = [9]\n}\n9: 2011(tag:Tdir, state=Cdump)\n@array[] of Dentry {\n[0]\tname = &quot;0411&quot;\n\tslot = 0\n\tdblock = [6]\t\t# from rba(current cw root)\n}\n106: cw root(tag:Tdir, state=Cdump, ver2)\n@array[DIRPERBUF] of Dentry {\n[0]\tname = &quot;/&quot;,\n\tslot = 0\n\tdblock = [6]\n}\n107: ro root(tag:Tdir, state=Cdump, ver2)\n@array[] of Dentry {\n[0]\tname = &quot;/&quot;,\n\tslot = 0\n\tdblock = [8]\n}</code></pre>\n\t\t\t\t<p>この後、しばらくすればwcpプロセスにより\n\t\t\t\tCdumpのものがWORMへ書き込まれます。</p>\n\t\t\t\t<figure>\n\t\t\t\t\t<img src=\"04282-2.png\" alt=\"WORMのレイアウト\">\n\t\t\t\t\t<figcaption>WORMのレイアウト</figcaption>\n\t\t\t\t</figure>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>ファイルの更新</h3>\n\t\t\t\t<p>ブロックの一部分だけ更新された場合、\n\t\t\t\t変更のあったブロックだけ切り替わります。\n\t\t\t\t以下は疑似コードですが、だいたいこんな感じ。</p>\n\t\t\t\t<pre><code class=\"c\">na = cwrecur(addr)\nif(na){\n\tblock[i] = na;\n\tp-&gt;flags |= Bmod;\n}</code></pre>\n\t\t\t\t<p>めんどくさいので図は省略。</p>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>おまけ</h3>\n\t\t\t\t<p>ファイルサーバのconfigは、\n\t\t\t\tnvramとディスクの0ブロックに分かれて保存されます。\n\t\t\t\t具体的には</p>\n\t\t\t\t<pre><code>config w0\nservice fs\nip 192.168...</code></pre>\n\t\t\t\t<p>この場合、w0という文字列がフロッピーのplan9.nvrに、\n\t\t\t\t構造体でいえばNvsafe.configに保存され、\n\t\t\t\t残りの部分はw0ディスクのブロック0に書き込まれます。\n\t\t\t\tこのとき、個々の行は改行(\\n)で区切られます。</p>\n\t\t\t</section>\n\t\t</section>\n\t</section>\n</main>\n<aside>\n\t<h1>参考サイト</h1>\n\t<ul>\n\t<li><a href=\"http://plan9.aichi-u.ac.jp/cwfs/\">cwfsの研究</a></li>\n\t</ul>\n</aside>\n<aside>\n\t<h1>やっていること</h1>\n\t<ul>\n\t<li><a href=\"/plan9/index.html\">Plan 9</a></li>\n\t<li><a href=\"http://web.me.com/lufia/alefcompiler/alef/\">Alefコンパイラを読む</a></li>\n\t</ul>\n</aside>\n<footer>\n\t<p>見れない、表示がおかしい場合は、動作環境を添えて<a href=\"mailto:webmaster@lufia.org\">webmaster@lufia.org</a>まで連絡ください。</p>\n</footer>\n</body>\n</html>\n"},"__N_SSG":true}