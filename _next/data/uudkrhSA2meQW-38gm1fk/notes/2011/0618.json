{"pageProps":{"html":"<!doctype html>\n<html lang=\"ja\">\n<head>\n<meta charset=\"utf-8\">\n<title>orange/note: il.cを読む</title>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n<meta name=\"author\" content=\"http://www.hatena.ne.jp/lufiabb/\">\n</head>\n<body>\n<nav>\n\t<h1>メニュー</h1>\n\t<ul>\n\t<li><a href=\"/notes/index.html\">orange/note</a></li>\n\t<li><a href=\"/notes/pc.html\">PC関連</a></li>\n\t<li><a href=\"/notes/web.html\">web製作</a></li>\n\t<li><a href=\"/notes/sec.html\">セキュリティ</a></li>\n\t<li><a href=\"/notes/hobby.html\">本・ゲーム</a></li>\n\t<li><a href=\"/notes/junk.html\">ジャンク</a></li>\n\t</ul>\n</nav>\n<main>\n\t<p class=\"revision\">2011年6月18日作成</p>\n\t<section>\n\t\t<h1>il.cを読む</h1>\n\t\t<div class=\"note\">\n\t\t\t<p>TCPの場合は、受信側がSeqを加算してAckに設定するが、\n\t\t\tILでは送信側がSeqを加算しているようにみえる。\n\t\t\tAckは最後に受信した相手側のSeqをそのまま送り返す？</p>\n\t\t</div>\n\t\t<section>\n\t\t\t<h2>定数</h2>\n\t\t\t<dl>\n\t\t\t<div>\n\t\t\t\t<dt>Nqt</dt>\n\t\t\t\t<dd>8</dd>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<dt>IL_IPSIZE</dt>\n\t\t\t\t<dd>IPヘッダのサイズ</dd>\n\t\t\t\t<dd>20</dd>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<dt>IL_HDRSIZE</dt>\n\t\t\t\t<dd>ILヘッダのサイズ; IP部分は含まない</dd>\n\t\t\t\t<dd>18</dd>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<dt>IL_LISTEN</dt>\n\t\t\t\t<dt>IL_CONNECT</dt>\n\t\t\t\t<dd>ilstartに渡す引数</dd>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<dt>IP_ILPROTO</dt>\n\t\t\t\t<dd>IPプロトコル番号</dd>\n\t\t\t\t<dd>40</dd>\n\t\t\t</div>\n\t\t\t</dl>\n\t\t\t<section>\n\t\t\t\t<h3>パケットタイプ</h3>\n\t\t\t\t<dl>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>sync</dt>\n\t\t\t\t\t<dt>data</dt>\n\t\t\t\t\t<dt>dataquery</dt>\n\t\t\t\t\t<dt>ack</dt>\n\t\t\t\t\t<dt>query</dt>\n\t\t\t\t\t<dt>state</dt>\n\t\t\t\t\t<dt>close</dt>\n\t\t\t\t\t<dd>xxx</dd>\n\t\t\t\t</div>\n\t\t\t\t</dl>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>接続状態</h3>\n\t\t\t\t<dl>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>Closed</dt>\n\t\t\t\t\t<dd>初期値または閉じた後</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>Syncer</dt>\n\t\t\t\t\t<dd>ilconnect(argv, argc)したとき</dd>\n\t\t\t\t\t<dd>connect側</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>Syncee</dt>\n\t\t\t\t\t<dd>listen側</dd>\n\t\t\t\t\t<dd>Listenを経てこれになる</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>Established</dt>\n\t\t\t\t\t<dd>接続中</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>Listen</dt>\n\t\t\t\t\t<dd>ilannounce()のとき</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>Closing</dt>\n\t\t\t\t\t<dd>閉じる処理中</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>Opening</dt>\n\t\t\t\t\t<dd>fileserverだけ?</dd>\n\t\t\t\t</div>\n\t\t\t\t</dl>\n\t\t\t</section>\n\t\t</section>\n\t\t<section>\n\t\t\t<h2>データ構造</h2>\n\t\t\t<section>\n\t\t\t\t<h3>Conv</h3>\n\t\t\t\t<p>conversation = 会話, 対話。コネクションにつき1つ割り当て。</p>\n\t\t\t\t<dl>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>raddr</dt>\n\t\t\t\t\t<dd>リモートアドレス(IP)</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>rport</dt>\n\t\t\t\t\t<dd>リモートポート</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>laddr</dt>\n\t\t\t\t\t<dd>ローカルアドレス(IP)</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>lport</dt>\n\t\t\t\t\t<dd>ローカルポート</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>pctl</dt>\n\t\t\t\t\t<dd>Ilcb, Udpcb, Tcp等が設定されるのでキャストして使う</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>p</dt>\n\t\t\t\t\t<dd>Proto</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>rq</dt>\n\t\t\t\t\t<dd>read queue</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>wq</dt>\n\t\t\t\t\t<dd>write queue</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>eq</dt>\n\t\t\t\t\t<dd>?</dd>\n\t\t\t\t</div>\n\t\t\t\t</dl>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>Block</h3>\n\t\t\t\t<p>データブロックのリスト。\n\t\t\t\tデータ本体はrpからwpの間に配置される。</p>\n\t\t\t\t<dl>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>rp</dt>\n\t\t\t\t\t<dd>データの開始ポインタ</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>wp</dt>\n\t\t\t\t\t<dd>データの末尾ポインタ</dd>\n\t\t\t\t\t<dd>書いたらwpが増えて、それを読んだらrpが増える</dd>\n\t\t\t\t\t<dd>wp += IL4_IPSIZE+IL_HDRSIZE</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>next</dt>\n\t\t\t\t\t<dd>blocklenで使っているリスト用</dd>\n\t\t\t\t\t<dd>次のデータブロック</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>link</dt>\n\t\t\t\t\t<dd>outoforderとかunackedで使っているリスト用</dd>\n\t\t\t\t</div>\n\t\t\t\t</dl>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>Ilcb</h3>\n\t\t\t\t<p>コントロールブロック。\n\t\t\t\t/net/il/$id/statusを読むと見れる。</p>\n\t\t\t\t<dl>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>state</dt>\n\t\t\t\t\t<dd>ILコネクションの状態</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>conv</dt>\n\t\t\t\t\t<dd>Convへの逆参照</dd>\n\t\t\t\t\t<dd>c-&gt;pctl-&gt;conv == cが成り立つ</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>ackq</dt>\n\t\t\t\t\t<dd>unacknowledge queue(ロック)</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>unacked</dt>\n\t\t\t\t\t<dd>list of ref Block</dd>\n\t\t\t\t\t<dd>まだackを受けていないブロックのリスト(早いものが先頭)</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>unackedtail</dt>\n\t\t\t\t\t<dd>unackedの末尾; 追加するとき使っている</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>unackedbytes</dt>\n\t\t\t\t\t<dd>unackedに残っているブロックの合計バイト数</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>outo</dt>\n\t\t\t\t\t<dd>out of order acket queue(ロック)</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>outoforder</dt>\n\t\t\t\t\t<dd>list of ref Block</dd>\n\t\t\t\t\t<dd>iloutoforderで追加+ソートして、ilpullupで取得</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>next</dt>\n\t\t\t\t\t<dd>次のデータメッセージで設定するID</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>recvd</dt>\n\t\t\t\t\t<dd>受信した最後のリモート側ilid</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>acksent</dt>\n\t\t\t\t\t<dd>確認のとれた最大ID(ローカル側)</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>start</dt>\n\t\t\t\t\t<dd>idの初期値(ローカル側; ランダム)</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>rstart</dt>\n\t\t\t\t\t<dd>idの初期値(リモート側; ランダム)</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>window</dt>\n\t\t\t\t\t<dd>ilidはrecvd &lt; ilid &lt;= recvd+window</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>rxquery</dt>\n\t\t\t\t\t<dt>rxtot</dt>\n\t\t\t\t\t<dt>rexmit</dt>\n\t\t\t\t\t<dd>タイムアウト用っぽい</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>qtx</dt>\n\t\t\t\t\t<dd>ilnextqt()を呼び出す度に、1..Nqt(8)でループ</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>qt</dt>\n\t\t\t\t\t<dd>ilnextqt()のときに、qt[qtx] = next-1</dd>\n\t\t\t\t\t<dd>旧バージョンと互換のため、qt[0]は常にnext-1</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>fasttimeout</dt>\n\t\t\t\t\t<dd>ilstartのとき、fasttimeoutが1ならこれも1</dd>\n\t\t\t\t</div>\n\t\t\t\t</dl>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>Ilhdr</h3>\n\t\t\t\t<p>実際に送るIP+ILヘッダ。</p>\n\t\t\t\t<dl>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>vihl</dt>\n\t\t\t\t\t<dt>tos</dt>\n\t\t\t\t\t<dt>length</dt>\n\t\t\t\t\t<dt>id</dt>\n\t\t\t\t\t<dt>frag</dt>\n\t\t\t\t\t<dt>ttl</dt>\n\t\t\t\t\t<dt>proto</dt>\n\t\t\t\t\t<dt>cksum</dt>\n\t\t\t\t\t<dt>src</dt>\n\t\t\t\t\t<dt>dst</dt>\n\t\t\t\t\t<dd>ここまでIPv4ヘッダ</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>ilsum</dt>\n\t\t\t\t\t<dd>チェックサム</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>illen</dt>\n\t\t\t\t\t<dd>パケット長(ILヘッダ+データ長)</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>iltype</dt>\n\t\t\t\t\t<dd>ILパケットタイプ</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>ilspec</dt>\n\t\t\t\t\t<dd>予約</dd>\n\t\t\t\t\t<dd>実際は再送カウントのような扱い</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>ilsrc</dt>\n\t\t\t\t\t<dd>送信元ポート番号</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>ildst</dt>\n\t\t\t\t\t<dd>送信先ポート番号</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>ilid</dt>\n\t\t\t\t\t<dd>シーケンス番号</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>ilack</dt>\n\t\t\t\t\t<dd>ACK</dd>\n\t\t\t\t</div>\n\t\t\t\t</dl>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>Ilpriv</h3>\n\t\t\t\t<p>ILコネクション全体で共有するデータ。</p>\n\t\t\t\t<dl>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>ht</dt>\n\t\t\t\t\t<dd>map of ref Conv</dd>\n\t\t\t\t\t<dd>ハッシュテーブル</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>stats</dt>\n\t\t\t\t\t<dd>array of oolong</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>csumerr</dt>\n\t\t\t\t\t<dt>hlenerr</dt>\n\t\t\t\t\t<dt>lenerr</dt>\n\t\t\t\t\t<dd>各種エラー</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>order</dt>\n\t\t\t\t\t<dt>rexmit</dt>\n\t\t\t\t\t<dt>dup</dt>\n\t\t\t\t\t<dt>dupb</dt>\n\t\t\t\t\t<dd>このあたりもエラー？</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>ackprocstarted</dt>\n\t\t\t\t\t<dd>ilstartでプロセスが起こっていれば1、まだなら0</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>apl</dt>\n\t\t\t\t\t<dd>プロセス生成のときに使うロック</dd>\n\t\t\t\t</div>\n\t\t\t\t</dl>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>Proto</h3>\n\t\t\t\t<dl>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>conv</dt>\n\t\t\t\t\t<dd>array of conversations</dd>\n\t\t\t\t\t<dd>いま発生しているコネクションの配列</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>nc</dt>\n\t\t\t\t\t<dd>conv数?</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>ac</dt>\n\t\t\t\t\t<dd>?</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>np</dt>\n\t\t\t\t\t<dd>?</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>f</dt>\n\t\t\t\t\t<dd>ilinit等で受けたFsポインタ</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>ipproto</dt>\n\t\t\t\t\t<dd>IPプロトコル番号</dd>\n\t\t\t\t\t<dd>ILの場合は40</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>priv</dt>\n\t\t\t\t\t<dd>Ilpriv, Udppriv, Tcpprivといったデータ</dd>\n\t\t\t\t</div>\n\t\t\t\t</dl>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>Fs</h3>\n\t\t\t\t<p>9Pファイルサーバ構造体っぽい。</p>\n\t\t\t</section>\n\t\t</section>\n\t\t<section>\n\t\t\t<h2>関数</h2>\n\t\t\t<section>\n\t\t\t\t<h3>char *ilconnect(Conv *c, char **argv, int argc)</h3>\n\t\t\t\t<p>argv, argcを使ってc-&gt;raddr, c-&gt;laddrを設定する。</p>\n\t\t\t\t<p>ここで、argv[1]はリモートアドレスを文字列で持つ。\n\t\t\t\targv[1]に!fasttimeoutを含んでいれば、fastモードに切り替わる。\n\t\t\t\tオプションでargv[2]にローカルアドレス。\n\t\t\t\targv[0]は使わない。</p>\n\t\t\t\t<p>未開始ならilstartでプロセスを生成する。\n\t\t\t\tアドレスの指定が間違っていればエラー文字列を返す。</p>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>int ilinuse(Conv *c)</h3>\n\t\t\t\t<p>cが使用中なら1を返す。\n\t\t\t\t具体的には、接続状態がClosed以外。</p>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>char *ilannounce(Conv *c, char **argv, int argc)</h3>\n\t\t\t\t<p>ilconnectと同じように処理する。\n\t\t\t\tただし、!fasttimeoutは認識せず、\n\t\t\t\t待ち受け状態(Syncee)になる。</p>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>void illocalclose(Conv *c)</h3>\n\t\t\t\t<p>ローカル側の接続を閉じる。\n\t\t\t\t接続状態はClosedになり、laddrとlportもリセットされる。</p>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>void ilclose(Conv *c)</h3>\n\t\t\t\t<p>c-&gt;[rwe]qを閉じ、接続を閉じる。\n\t\t\t\tcがEstablished, Syncee, Syncerなら状態をClosingに変えて、\n\t\t\t\tcloseコマンドを送る。また、Listenならillocalcloseする。</p>\n\t\t\t\t<p>閉じるだけ、freeはしない。</p>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>void ilkick(void *x, Block *bp)</h3>\n\t\t\t\t<p>ilcreateで、wq = qbypass(ilkick, c)されるもの。\n\t\t\t\tおそらくデータの送信に使われるのだろう。</p>\n\t\t\t\t<p>xはConv*なので、それをもとにbpをdataメッセージに加工、\n\t\t\t\t構築して投げる。と同時に、ack待ちリストにもコピーを追加。\n\t\t\t\tちなみに、これが呼ばれた時点で、bpにはデータしかない。\n\t\t\t\tなのでpadblockで先頭にヘッダ分を確保して、\n\t\t\t\tそこにILヘッダを組み立てている。</p>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>void ilcreate(Conv *c)</h3>\n\t\t\t\t<p>c-&gt;rq, c-&gt;wqの初期化。</p>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>void ilackq(Ilcb *ic, Block *bp)</h3>\n\t\t\t\t<p>bpをひとつの大きなブロックにコピーして、\n\t\t\t\tic-&gt;unackedの末尾に追加する。</p>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>Block *copyblock(Block *bp, int count)</h3>\n\t\t\t\t<p>ブロックのリスト(bp)を、\n\t\t\t\t新しいブロックにcountバイトだけコピーして返す。</p>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>void ilackto(Ilcb *ic, ulong ackto, Block *bp)</h3>\n\t\t\t\t<p>unackedなリストから、\n\t\t\t\tacktoまで(含む)のパケットを承認されたものとする。\n\t\t\t\t結果的にunackedから消え、unackedbytesも減る。</p>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>Conv *iphtlook(Ipht *ht, uchar *sa, ushort sp, uchar *da, ushort dp)</h3>\n\t\t\t\t<p>送信元/送信先のIPアドレス+ポートでテーブルを検索。\n\t\t\t\t一致の条件は、Listenの場合はいろいろ省略されたりする。</p>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>void iliput(Proto *il, Ipifc*, Block *bp)</h3>\n\t\t\t\t<p>パケットを受信したとき呼ばれる関数。</p>\n\t\t\t\t<dl>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>dp</dt>\n\t\t\t\t\t<dd>bpの送信元ポート</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>sp</dt>\n\t\t\t\t\t<dd>bpの送信先ポート</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>raddr</dt>\n\t\t\t\t\t<dd>bpの送信元IPアドレス</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>laddr</dt>\n\t\t\t\t\t<dd>bpの送信先IPアドレス</dd>\n\t\t\t\t</div>\n\t\t\t\t</dl>\n\t\t\t\t<p>で、コネクションテーブルからこの条件で検索して、\n\t\t\t\t見つかったものがListenな接続なら、\n\t\t\t\t新しい接続(Conv)を作って対象をそれと置き換える。\n\t\t\t\t元のListen接続はそのままで、新しいほうはSynceeとなる。\n\t\t\t\tリモート側のシーケンス番号もここで設定。</p>\n\t\t\t\t<p>最後にilprocess()を呼び出している。</p>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>void ilprocess(Conv *s, Ilhdr *h, Block *bp)</h3>\n\t\t\t\t<p>パケットを受信したときのメイン処理。\n\t\t\t\t基本的にはbp-&gt;rp == sだが、Listenした場合は違う。</p>\n\t\t\t\t<section>\n\t\t\t\t\t<h4>Syncer(connect側)の場合</h4>\n\t\t\t\t\t<p>syncメッセージを受信したならackを返してEstablishへ移行、\n\t\t\t\t\tその後にilpullupする。</p>\n\t\t\t\t\t<p>closeメッセージの場合はfreeblist。</p>\n\t\t\t\t</section>\n\t\t\t\t<section>\n\t\t\t\t\t<h4>Syncee(listen側)の場合</h4>\n\t\t\t\t\t<p>syncを受けてrecvdをそのidに設定、\n\t\t\t\t\tsyncメッセージをid=start, ack=recvdとして投げ返す。</p>\n\t\t\t\t\t<p>ackを受信するとEstablishへ移行、ilpullupする。</p>\n\t\t\t\t\t<p>dataを受信した場合もEstablishへ移行するが、\n\t\t\t\t\tpullupしないでそのまま処理する。</p>\n\t\t\t\t</section>\n\t\t\t\t<section>\n\t\t\t\t\t<h4>Establishの場合</h4>\n\t\t\t\t\t<p>sendを受信したらすぐack(id=next, ack=rstart)。</p>\n\t\t\t\t\t<p>dataの場合は、それに含まれるackまでを承認して、\n\t\t\t\t\t受信したデータをoutoforderへ追加、ilpullupする。</p>\n\t\t\t\t\t<p>dataqueryならdataと同じ処理をして、\n\t\t\t\t\t最後にstate(id=next, ack=recvd)を投げる。</p>\n\t\t\t\t\t<p>ackなら承認するだけ。</p>\n\t\t\t\t\t<p>queryはdataqueryと似ているが、\n\t\t\t\t\tこちらはデータが無いのでiloutoforderもilpullupもない。</p>\n\t\t\t\t\t<p>stateを受信したら、ack承認した後、\n\t\t\t\t\tilrexmitとilsettimeoutしている。\n\t\t\t\t\tなんだか普通にIlhdr.ilspecが使われているけど、\n\t\t\t\t\tこれはどういうことだろう。</p>\n\t\t\t\t\t<p>closeを受ければそのままclose(id=next, ack=recvd)。\n\t\t\t\t\t状態はClosingになる。</p>\n\t\t\t\t</section>\n\t\t\t\t<section>\n\t\t\t\t\t<h4>Closingの場合</h4>\n\t\t\t\t\t<p>closeメッセージ受信でclose(id=next, ack=recvd)を返信。\n\t\t\t\t\trecvdはこのとき受信したidです。</p>\n\t\t\t\t</section>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>void ilrexmit(Ilcb *ic)</h3>\n\t\t\t\t<p>unackedの先頭にあるメッセージをコピーして再送する。\n\t\t\t\tこのときの型はdataqueryで、ackは再送時のrecvdに変わるが、\n\t\t\t\tidは最初に送ったものから変化しない。</p>\n\t\t\t\t<p>それよりも送るデータのilspecを\n\t\t\t\tilnextqt(ic)の値に設定しているのが気になる。</p>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>void ilhangup(Conv *s, char *msg)</h3>\n\t\t\t\t<p>いろいろなものを終了している。illocalclose(s)とか。</p>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>void ilpullup(Conv *s)</h3>\n\t\t\t\t<p>Ilestablished以外なら何もしない。</p>\n\t\t\t\t<p>正しい順番でs-&gt;outoforderなリストをs-&gt;rqへ渡す。\n\t\t\t\tここで、分割されたブロックならひとつにまとめる。</p>\n\t\t\t\t<p>もし先にうしろのデータが届いたら、\n\t\t\t\t貯めておいてあとからまとめて処理する。</p>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>void iloutoforder(Conv *s, Ilhdr *h, Block *bp)</h3>\n\t\t\t\t<p>s-&gt;outoforderへ(h+bp)を追加する。\n\t\t\t\tこのとき、ilid(シーケンス番号)順になるよう調整する。\n\t\t\t\t同じIDが現れたときは後のものを優先っぽい？</p>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>void ilsendctl(Conv *ipc, Ilhdr *inih, int type, ulong id, ulong ack, int ilspec)</h3>\n\t\t\t\t<p>ipcのアドレスとポートをもとにBlockを作り、\n\t\t\t\tそれをipoput4に渡して送信する。\n\t\t\t\tBlockの後ろ(Block.rpからwpの範囲)にはIlhdrが続く。\n\t\t\t\tこのIlhdrを構成するとき、type, id, ilspecが使われる。</p>\n\t\t\t\t<p>または、inihがnilでなければ、上記の代わりにこれが使われる。</p>\n\t\t\t\t<p>ipoput4に渡されるIlhdrは、\n\t\t\t\tinihの送信元/送信先IP+ポートとは逆になる。</p>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>Block *allocb(int size)</h3>\n\t\t\t\t<p>sizeof(Block)+size+Hdrspcな領域を確保して返す。\n\t\t\t\trpとwpは多少ずれる可能性があるが、\n\t\t\t\t基本的にBlockのうしろを指す。</p>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>void ilackproc(void *x)</h3>\n\t\t\t\t<p>ilstartで開始されるプロセスの中身。\n\t\t\t\t主にいま残っているコネクションをみて、\n\t\t\t\tそれらのタイムアウトを処理している。</p>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>char *ilstart(Conv *c, int type, int fasttimeout)</h3>\n\t\t\t\t<p>まだなければilackprocを処理するプロセスを立てる。\n\t\t\t\tプロトコルにつき1プロセス。</p>\n\t\t\t\t<p>その後、typeフラグにより2通りに別れる。</p>\n\t\t\t\t<section>\n\t\t\t\t\t<h4>IL_LISTEN</h4>\n\t\t\t\t\t<p>状態をListenにして、\n\t\t\t\t\tc-&gt;p-&gt;priv(Ilpriv)のhtテーブルへcを登録。</p>\n\t\t\t\t</section>\n\t\t\t\t<section>\n\t\t\t\t\t<h4>IL_CONNECT</h4>\n\t\t\t\t\t<p>Syncer状態でIlpriv.htへcを登録し、\n\t\t\t\t\tilsendctl(ilsync)を呼び出す。\n\t\t\t\t\tこれによりsyncメッセージを投げる。</p>\n\t\t\t\t</section>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>void ilfreeq(Ilcb *ic)</h3>\n\t\t\t\t<p>icから、unackedとoutoforderリストを解放する。\n\t\t\t\tic自体は残る。</p>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>void iladvise(Proto *il, Block *bp, char *msg)</h3>\n\t\t\t\t<p>il.convから送信元IP, 送信先IP, 送信元ポート番号が\n\t\t\t\tbpと一致するものを調べて、それがIlsyncerならhangupさせる。\n\t\t\t\t最後に、一致していてもしなくてもbpを解放。</p>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>int ilnextqt(Ilcb *ic)</h3>\n\t\t\t\t<p>icの、qtxとqtを設定。1..8でループ。</p>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>void ilinit(Fs *f)</h3>\n\t\t\t\t<p>connect, announce, rcv等の関数をfに設定して、\n\t\t\t\tそれをfにil用ルーチンとして登録。</p>\n\t\t\t</section>\n\t\t</section>\n\t</section>\n</main>\n<aside>\n\t<h1>関連情報</h1>\n\t<ul>\n\t<li><a href=\"0704.html\">IL/IPv6対応</a></li>\n\t<li><a href=\"../../plan9/doc/guide/il.html\">ILプロトコル</a></li>\n\t<li><a href=\"../../plan9/doc/inst/il.html\">カーネルにilを組み込む</a></li>\n\t</ul>\n</aside>\n<aside>\n\t<h1>やっていること</h1>\n\t<ul>\n\t<li><a href=\"/plan9/index.html\">Plan 9</a></li>\n\t<li><a href=\"http://web.me.com/lufia/alefcompiler/alef/\">Alefコンパイラを読む</a></li>\n\t</ul>\n</aside>\n<footer>\n\t<p>見れない、表示がおかしい場合は、動作環境を添えて<a href=\"mailto:webmaster@lufia.org\">webmaster@lufia.org</a>まで連絡ください。</p>\n</footer>\n</body>\n</html>\n"},"__N_SSG":true}