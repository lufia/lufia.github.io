{"pageProps":{"html":"<!doctype html>\n<html lang=\"ja\">\n<head>\n<meta charset=\"utf-8\">\n<title>orange/note: ファイルサーバを読む</title>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n<meta name=\"author\" content=\"http://www.hatena.ne.jp/lufiabb/\">\n</head>\n<body>\n<nav>\n\t<h1>メニュー</h1>\n\t<ul>\n\t<li><a href=\"/notes/index.html\">orange/note</a></li>\n\t<li><a href=\"/notes/pc.html\">PC関連</a></li>\n\t<li><a href=\"/notes/web.html\">web製作</a></li>\n\t<li><a href=\"/notes/sec.html\">セキュリティ</a></li>\n\t<li><a href=\"/notes/hobby.html\">本・ゲーム</a></li>\n\t<li><a href=\"/notes/junk.html\">ジャンク</a></li>\n\t</ul>\n</nav>\n<main>\n\t<p class=\"revision\">2011年5月17日更新</p>\n\t<section>\n\t\t<h1>ファイルサーバを読む</h1>\n\t\t<section>\n\t\t\t<h2>ブロック</h2>\n\t\t\t<p>以下でいうブロックとは論理ブロックで、\n\t\t\t特定の場合を除いて、ディスクの物理ブロックとは異なります。\n\t\t\tキャッシュもWORMも同じ大きさで8KB。</p>\n\t\t</section>\n\t\t<section>\n\t\t\t<h2>チャネル</h2>\n\t\t\t<p>ファイルサーバに9pで接続しているコネクション。\n\t\t\tファイルサーバのコンソールも含みます。</p>\n\t\t</section>\n\t\t<section>\n\t\t\t<h2>バッファ</h2>\n\t\t\t<p>ディスクブロックにアクセスする際、\n\t\t\tファイルサーバは必ずバッファを通して読み書きします。\n\t\t\tgetbufはデバイスとアドレスを取り、\n\t\t\tそれのバッファを用意してロックします。\n\t\t\tputbufはその逆です。</p>\n\t\t\t<p>Cache-WORMデバイスの場合は、\n\t\t\tキャッシュディスクにWORMのデータを読み込んだり、\n\t\t\tdumpの時にキャッシュのデータをWORMへ反映したりします。\n\t\t\tバッファの詳細は下のほうで。</p>\n\t\t</section>\n\t\t<section>\n\t\t\t<h2>デバイス</h2>\n\t\t\t<dl>\n\t\t\t<div>\n\t\t\t\t<dt>Cache-WORM(cw)</dt>\n\t\t\t\t<dd>キャッシュとWORMを両方持つデバイス</dd>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<dt>dump(ro)</dt>\n\t\t\t\t<dd>9fs dumpしたときに見えるデバイス(2011/0411とか)</dd>\n\t\t\t\t<dd>リードオンリー</dd>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<dt>Cache(c)</dt>\n\t\t\t\t<dd>キャッシュ</dd>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<dt>WORM(w)</dt>\n\t\t\t\t<dd>WORM</dd>\n\t\t\t\t<dd>だいたいCache-WORMの一部分</dd>\n\t\t\t</div>\n\t\t\t</dl>\n\t\t\t<p>別の記事で<a href=\"../2010/0705.html\">fsバックアップメモ</a>も参考に。</p>\n\t\t</section>\n\t\t<section>\n\t\t\t<h2>アドレス</h2>\n\t\t\t<p>ファイルサーバのなかで管理しているアドレスは、\n\t\t\tデバイスごとに違うものとして扱われます。\n\t\t\tなので、getbuf(cw, 2)をマップした結果、\n\t\t\tそのキャッシュブロックアドレスが10としても、\n\t\t\tそれとgetbuf(c, 10)は異なるアドレスとして扱われます。</p>\n\t\t</section>\n\t\t<section>\n\t\t\t<h2>アドレス変換</h2>\n\t\t\t<p>Cache-WORMデバイスを扱う場合は、\n\t\t\tWORMアドレスからキャッシュのデータブロックへマップするため、\n\t\t\tアドレス変換が発生します。\n\t\t\tこのとき、getbufに与えるアドレスはWORMアドレスです。</p>\n\t\t\t<p>詳細は<a href=\"04282.html\">ファイルサーバのディスクレイアウト</a>に。</p>\n\t\t</section>\n\t\t<section>\n\t\t\t<h2>データ構造</h2>\n\t\t\t<section>\n\t\t\t\t<h3>ブロックアドレス関連の定数</h3>\n\t\t\t\t<dl>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>CACHE_ADDR</dt>\n\t\t\t\t\t<dd>Cacheディスク構成情報などが配置されるブロックアドレス</dd>\n\t\t\t\t\t<dd>2</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>SUPER_ADDR</dt>\n\t\t\t\t\t<dd>WORMにある最初のスーパーブロックアドレス</dd>\n\t\t\t\t\t<dd>2</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>ROOT_ADDR</dt>\n\t\t\t\t\t<dd>WORMのルートブロックアドレス</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>RBUFSIZE</dt>\n\t\t\t\t\t<dd>論理ブロックの大きさ</dd>\n\t\t\t\t\t<dd>具体的には8KB(8192)</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>BUFSIZE</dt>\n\t\t\t\t\t<dd>RBUFSIZEからタグのぶんを除いた、データを持てる大きさ</dd>\n\t\t\t\t\t<dd>BUFSIZE+sizeof(Tag) == RBUFSIZE</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>BKPERBLK</dt>\n\t\t\t\t\t<dd>1つのブロックに含まれるBucket数</dd>\n\t\t\t\t\t<dd>10</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>CEPERBK</dt>\n\t\t\t\t\t<dd>Bucketに含まれるCentry数</dd>\n\t\t\t\t\t<dd>だいたい50</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>ADDFREE</dt>\n\t\t\t\t\t<dd>grow時に増えるWORMブロック数</dd>\n\t\t\t\t\t<dd>100</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>DIRPERBUF</dt>\n\t\t\t\t\t<dd>1論理ブロックに保存できるDentry数</dd>\n\t\t\t\t</div>\n\t\t\t\t</dl>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>ブロックの種類</h3>\n\t\t\t\t<dl>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>Tfile</dt>\n\t\t\t\t\t<dd>ファイル</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>Tdir</dt>\n\t\t\t\t\t<dd>ディレクトリ</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>Tsuper</dt>\n\t\t\t\t\t<dd>WORMのスーパーブロック</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>Tind1</dt>\n\t\t\t\t\t<dd>1段目の間接参照ブロック</dd>\n\t\t\t\t\t<dd>2段目、3段目はTind1+1, Tind1+2となる</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>Tfree</dt>\n\t\t\t\t\t<dd>フリーリスト</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>Tbuck</dt>\n\t\t\t\t\t<dd>キャッシュディスクのマップブロック</dd>\n\t\t\t\t</div>\n\t\t\t\t</dl>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>ブロックの状態</h3>\n\t\t\t\t<dl>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>Cread</dt>\n\t\t\t\t\t<dd>WORMに書き込み後、変更がまだないブロック</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>Cwrite</dt>\n\t\t\t\t\t<dd>WORMに書き込み後、変更のあったブロック</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>Cdirty</dt>\n\t\t\t\t\t<dd>新しく確保されたブロックで、WORMにもない</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>Cdump</dt>\n\t\t\t\t\t<dd>dumpキューに入っているブロック</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>Cdump1</dt>\n\t\t\t\t\t<dd>dumpエラーのブロック?</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>Cnone</dt>\n\t\t\t\t\t<dd>未確保</dd>\n\t\t\t\t</div>\n\t\t\t\t</dl>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>Centry</h3>\n\t\t\t\t<p>WORMアドレスとキャッシュディスクのブロックを関連付けするもの。\n\t\t\t\t詳細は下のほうに。</p>\n\t\t\t\t<dl>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>waddr</dt>\n\t\t\t\t\t<dd>WORMブロックのアドレス</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>state</dt>\n\t\t\t\t\t<dd>ブロックの状態</dd>\n\t\t\t\t</div>\n\t\t\t\t</dl>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>Bucket</h3>\n\t\t\t\t<p>Centryの配列を持つ。\n\t\t\t\tこれが1ブロックにBKPERBLK個数格納される。\n\t\t\t\tこのあたりは<a href=\"04282.html\">ファイルサーバのディスクレイアウト</a>を参照。</p>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>Cache</h3>\n\t\t\t\t<p>キャッシュの状態と、一部、WORMの状態を持つ。\n\t\t\t\t常にキャッシュディスクのCACHE_ADDRに置かれる。</p>\n\t\t\t\t<dl>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>msize</dt>\n\t\t\t\t\t<dd>Bucket数</dd>\n\t\t\t\t\t<dd>msizeとなっているがブロック数ではない</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>maddr</dt>\n\t\t\t\t\t<dd>マップ領域(Bucket)の開始アドレス</dd>\n\t\t\t\t\t<dd>常にCACHE_ADDR+1 = 3</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>caddr</dt>\n\t\t\t\t\t<dd>データ領域の先頭ブロックアドレス</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>csize</dt>\n\t\t\t\t\t<dd>キャッシュディスクの使用可能なfs論理ブロック数</dd>\n\t\t\t\t\t<dd>マップ領域分(msize/BKPERBLK)は含まない</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>sbaddr</dt>\n\t\t\t\t\t<dt>cwraddr</dt>\n\t\t\t\t\t<dt>roraddr</dt>\n\t\t\t\t\t<dt>next</dt>\n\t\t\t\t\t<dt>fsize</dt>\n\t\t\t\t\t<dt>wsize</dt>\n\t\t\t\t\t<dd>これらはSuperbの同名変数と同じ値を維持している</dd>\n\t\t\t\t</div>\n\t\t\t\t</dl>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>Superb</h3>\n\t\t\t\t<p>WORMに保存されるスーパーブロック。</p>\n\t\t\t\t<dl>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>last</dt>\n\t\t\t\t\t<dd>そのSuperbからみて前回のスーパーブロックアドレス</dd>\n\t\t\t\t\t<dd>最初は2</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>cwraddr</dt>\n\t\t\t\t\t<dd>ルートブロックのアドレス</dd>\n\t\t\t\t\t<dd>最初は3</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>roraddr</dt>\n\t\t\t\t\t<dd>dumpデバイスのルートアドレス</dd>\n\t\t\t\t\t<dd>最初は4</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>next</dt>\n\t\t\t\t\t<dd>次のスーパーブロックアドレス</dd>\n\t\t\t\t\t<dd>最初は5</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>fstart</dt>\n\t\t\t\t\t<dd>2</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>fsize</dt>\n\t\t\t\t\t<dd>使用中WORMブロック数</dd>\n\t\t\t\t\t<dd>最初は6</dd>\n\t\t\t\t\t<dd>fsgrow()のときにADDFREEだけまとめて増える</dd>\n\t\t\t\t\t<dd>dumpのときにもCwriteブロックの場合に1増える</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>wsize</dt>\n\t\t\t\t\t<dd>WORMブロック数</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>fbuf</dt>\n\t\t\t\t\t<dd>フリーブロック</dd>\n\t\t\t\t</div>\n\t\t\t\t</dl>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>Fbuf</h3>\n\t\t\t\t<p>フリーブロックアドレスの配列。\n\t\t\t\t新しいブロックが割り当てられる(Cdirty)時に後ろから使われる。</p>\n\t\t\t\t<p>これがFEPERBUFを超えると、超えたFbufをブロックへ書き、\n\t\t\t\t新しいフリーブロックの先頭に書きこんだアドレスを設定する。\n\t\t\t\tこのため、間接参照みたいな扱いになる。\n\t\t\t\tこのときのtagはTfree。</p>\n\t\t\t\t<dl>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>nfree</dt>\n\t\t\t\t\t<dd>ブロックの個数</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>free</dt>\n\t\t\t\t\t<dd>フリーブロックのアドレス配列</dd>\n\t\t\t\t\t<dd>0のみ特別</dd>\n\t\t\t\t</div>\n\t\t\t\t</dl>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>Cw</h3>\n\t\t\t\t<p>キャッシュWORM</p>\n\t\t\t\t<dl>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>fsize</dt>\n\t\t\t\t\t<dd>dumpのときに共有変数っぽく使う</dd>\n\t\t\t\t\t<dd>意味はCacheなどのそれと同じ</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>daddr</dt>\n\t\t\t\t\t<dd>dump対象となったブロックアドレスっぽい</dd>\n\t\t\t\t</div>\n\t\t\t\t</dl>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>Wren</h3>\n\t\t\t\t<p>物理的な磁気ディスク。</p>\n\t\t\t\t<dl>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>nblock</dt>\n\t\t\t\t\t<dd>SCSI論理ブロック数</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>block</dt>\n\t\t\t\t\t<dd>SCSIブロック長</dd>\n\t\t\t\t\t<dd>単位はバイト</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>mult</dt>\n\t\t\t\t\t<dd>RBUFSIZEを確保するのに必要なSCSI論理ブロック数</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>max</dt>\n\t\t\t\t\t<dd>最大ブロック数</dd>\n\t\t\t\t\t<dd>ブロックのサイズはRBUFSIZE</dd>\n\t\t\t\t</div>\n\t\t\t\t</dl>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>Iobuf</h3>\n\t\t\t\t<p>各種ブロック操作を行うときに使うバッファ。\n\t\t\t\tgetbufにより空いているバッファがロックされ使用中になり、\n\t\t\t\tputbufによってロック解除され未使用状態に戻る。</p>\n\t\t\t\t<dl>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>addr</dt>\n\t\t\t\t\t<dd>WORMアドレス</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>dev</dt>\n\t\t\t\t\t<dd>デバイス</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>flags</dt>\n\t\t\t\t\t<dd>BmodとかBreadとかのフラグ</dd>\n\t\t\t\t\t<dd>これはputbufで処理(キャッシュに書き込むなど)</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>iobuf</dt>\n\t\t\t\t\t<dd>各種操作を行うためのバッファ</dd>\n\t\t\t\t\t<dd>Iobufが使われていない場合はnilになっている</dd>\n\t\t\t\t\t<dd>read/writeなどで使う</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>xiobuf</dt>\n\t\t\t\t\t<dd>実際のバッファ</dd>\n\t\t\t\t\t<dd>事前にメモリを確保していて、iobufmapによりこれをiobufへ設定</dd>\n\t\t\t\t</div>\n\t\t\t\t</dl>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>Dentry</h3>\n\t\t\t\t<p>ディレクトリエントリ。\n\t\t\t\t直接ブロック6個、間接ブロック4個などの情報が保存されている。\n\t\t\t\tfs64の場合、1つのブロックに47個入るらしい。</p>\n\t\t\t\t<p>ディレクトリがブロックをまたいで分断されることはない。\n\t\t\t\tなので(mode&amp;DDIR)なら、\n\t\t\t\tdblock[0]もdblock[1]もgetdir(block, i)が使える。</p>\n\t\t\t\t<dl>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>mode</dt>\n\t\t\t\t\t<dd>パーミッション</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>dblock</dt>\n\t\t\t\t\t<dd>直接ブロックのアドレス配列</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>iblocks</dt>\n\t\t\t\t\t<dd>間接ブロックのアドレス配列</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>slot</dt>\n\t\t\t\t\t<dd>バッファ中のインデックス</dd>\n\t\t\t\t\t<dd>同じ親ディレクトリでも、ブロックが異なればまた0からはじまる</dd>\n\t\t\t\t</div>\n\t\t\t\t</dl>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>File</h3>\n\t\t\t\t<p>オープンファイル。\n\t\t\t\t詳細は<a href=\"0516.html\">fsオープンファイルの管理</a>を参照。</p>\n\t\t\t\t<dl>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>cp</dt>\n\t\t\t\t\t<dd>ファイルを扱っているチャネル</dd>\n\t\t\t\t\t<dd>未使用ならnil</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>wpath</dt>\n\t\t\t\t\t<dd>親ディレクトリを指すリスト</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>addr</dt>\n\t\t\t\t\t<dd>ファイルのDentryが保存されているブロックアドレス</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>slot</dt>\n\t\t\t\t\t<dd>ファイルのDentry中で、何番目のDentryかを指すオフセット</dd>\n\t\t\t\t</div>\n\t\t\t\t</dl>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>Wpath</h3>\n\t\t\t\t<p>オープンファイルについて、その親ディレクトリを指す。</p>\n\t\t\t\t<dl>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>up</dt>\n\t\t\t\t\t<dd>さらに上位ディレクトリ</dd>\n\t\t\t\t\t<dd>Wpathが/の場合はnil</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>refs</dt>\n\t\t\t\t\t<dd>参照カウント</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>addr</dt>\n\t\t\t\t\t<dt>slot</dt>\n\t\t\t\t\t<dd>Fileのそれと同じ</dd>\n\t\t\t\t</div>\n\t\t\t\t</dl>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>グローバル変数</h3>\n\t\t\t\t<dl>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>flist</dt>\n\t\t\t\t\t<dd>オープンファイルのリスト</dd>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<dt>sdevs</dt>\n\t\t\t\t\t<dd>たぶんディスクコントローラ</dd>\n\t\t\t\t</div>\n\t\t\t\t</dl>\n\t\t\t</section>\n\t\t</section>\n\t\t<section>\n\t\t\t<h2>各種操作</h2>\n\t\t\t<section>\n\t\t\t\t<h3>バッファ</h3>\n\t\t\t\t<p>ファイルサーバは、ディスクのブロックにアクセスする場合、\n\t\t\t\tgetbufとputbufを使って、必ずバッファを通して扱います。</p>\n\t\t\t\t<pre><code class=\"c\">getbuf(dev, addr)</code></pre>\n\t\t\t\t<p>単純にするため引数を一部省略していますが、getbufは、\n\t\t\t\tデバイスとWORMアドレスを使ってバッファを使用可能にします。\n\t\t\t\t必要ならWORMからバッファへ読み込んだりもします。\n\t\t\t\t次のはあくまで疑似コード。実際は全然違うけど雰囲気だけ。</p>\n\t\t\t\t<pre><code class=\"c\">mem: array of list of ref Iobuf\n\ngetbuf(dev: ref Device, addr: Off): ref Iobuf\n{\n\tlist = mem[hash(addr)].find(a =&gt; !a.used);\n\tc = list.find(a =&gt; a.dev == dev &amp;&amp; a.addr == addr);\n\tif(c == nil)\n\t\tc = list.last;\n\tlock(c);\n\tc.dev = dev;\n\tc.addr = addr;\n\t必要なデータの準備(c);\n\treturn c;\n}</code></pre>\n\t\t\t\t<p>必要なデータの準備のところで、\n\t\t\t\t実際にブロックへ読み書きをします。\n\t\t\t\tCache-WORMデバイスの場合は以下のように呼び出しします。</p>\n\t\t\t\t<pre><code class=\"c\">getbuf(cw-&gt;dev, up-&gt;addr, Bread|Bmod)\ndevread(cw-&gt;dev, up-&gt;addr, buf)\t# 0なら正常終了\ncwread(cw-&gt;dev, up-&gt;addr, buf)\ncwio(cw-&gt;dev, up-&gt;addr, buf, Oread)</code></pre>\n\t\t\t\t<p>ここから下はふつうにSCSIコマンド。</p>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>ream</h3>\n\t\t\t\t<p>Cache, Superb, 2つのルート(cwとro)を設定します。\n\t\t\t\tこれも<a href=\"../2010/0705.html\">fsバックアップメモ</a>のほうに。</p>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>grow</h3>\n\t\t\t\t<p>必要に応じてWORMの容量を増加させます。\n\t\t\t\t増加したブロックは、フリーブロックリストに移ります。</p>\n\t\t\t\t<pre><code class=\"c\">cwgrow: fn(dev: ref Device, sb: ref Superb, uid: int): int\n{\n\th: ref Cache;\n\th = getbuf(CDEV(dev), CACHE_ADDR, ...);\n\th.fsize += ADDFREE;\n\tif(h.fsize &gt;= h.wsize)\n\t\th.fsize = h.wsize;\n\n\tsb-&gt;fsize = h.fsize;\n\tfor(waddr in 増えたブロックについて){\n\t\tcwio(dev, waddr, 0, Ogrow);\n\t\taddfree(dev, waddr, sb);\n\t}\n}</code></pre>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>remove</h3>\n\t\t\t\t<p>ファイルを削除したとき、\n\t\t\t\tそのファイルが使用しているブロックをみて、\n\t\t\t\tそれがCdirtyならフリーリストへ戻します。\n\t\t\t\tCwriteなどの場合は再利用すると整合性が取れなくなるので、\n\t\t\t\tフリーリストへは戻しません。</p>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>recover</h3>\n\t\t\t\t<p>いちばん新しいdumpの状態に戻します。\n\t\t\t\t実際の動きは<a href=\"../2010/0705.html\">fsバックアップメモ</a>を参照。</p>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>dump(queue)</h3>\n\t\t\t\t<p>ファイルサーバは朝5:00に、\n\t\t\t\tその時点のバックアップをWORMへ書き込むのですが、\n\t\t\t\tそれは変更のあったブロックをdumpキューへ入れる部分と、\n\t\t\t\tキューのブロックを実際に書き込む部分に分かれています。\n\t\t\t\tここではキューに入れるところについて。</p>\n\t\t\t\t<p>まず、ファイルサーバは、ファイルの操作ができないように\n\t\t\t\t全体をロックします。\n\t\t\t\t変更のあったブロックは必ずキャッシュに残っているので、\n\t\t\t\tキャッシュディスクから変更のあったブロックをみて、\n\t\t\t\tその状態をCdumpに書き換えます。\n\t\t\t\tここで、実際はデータ領域ではなくマップ領域をみて、\n\t\t\t\tそのブロックが変更されていなければ飛ばします。</p>\n\t\t\t\t<p>変更のあったブロックで、その状態がCwriteの場合、\n\t\t\t\t新しいブロックアドレスを割り当てます。\n\t\t\t\tこれはフリーブロックを使いません。\n\t\t\t\tWORMディスクの容量(fsize)を増やしながら割り当てます。</p>\n\t\t\t\t<pre><code class=\"c\">na = cw-&gt;fsize++\ncwio(cw-&gt;dev, na, 0, Ogrow)\ncwio(cw-&gt;dev, na, p-&gt;iobuf, Owrite)\ncwio(cw-&gt;dev, na, 0, Odump)\ncwio(cw-&gt;dev, addr, 0, Orele)</code></pre>\n\t\t\t\t<p>Cdirtyの場合はまだ未使用なのでそのままです。</p>\n\t\t\t\t<pre><code>cwio(cw-&gt;dev, addr, 0, Odump)</code></pre>\n\t\t\t\t<p>この再割り当てはcwrecur関数が処理しています。\n\t\t\t\tこれは深さ優先で探索するので、\n\t\t\t\t深い場所のほうが小さいアドレスになるみたい。\n\t\t\t\tで、どこかに変更があった場合はrootがwriteになっているので、\n\t\t\t\t最後の戻り値が新しいルートの値(最大アドレス)となっている。\n\t\t\t\tちなみに、cwrecurの戻り値は、変更がなければ0。</p>\n\t\t\t\t<p>アドレスの再割り当てが終わったら、\n\t\t\t\trewalk関数により、オープンファイルが\n\t\t\t\t持っているアドレスを新しいアドレスに更新して、\n\t\t\t\tサーバの処理を再開します。</p>\n\t\t\t\t<div class=\"note\">\n\t\t\t\t\t<p>OreleとOfreeの違いは、</p>\n\t\t\t\t\t<dl>\n\t\t\t\t\t<div>\n\t\t\t\t\t\t<dt>rele</dt>\n\t\t\t\t\t\t<dd>writeならnoneに</dd>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div>\n\t\t\t\t\t\t<dt>free</dt>\n\t\t\t\t\t\t<dd>writeまたはreadならnone</dd>\n\t\t\t\t\t</div>\n\t\t\t\t\t</dl>\n\t\t\t\t</div>\n\t\t\t</section>\n\t\t\t<section>\n\t\t\t\t<h3>dump(copy)</h3>\n\t\t\t\t<p>キューに入れられたブロックについて、\n\t\t\t\tその内容をWORMに書き込むプロセスをwcpといいます。\n\t\t\t\tこれは朝5:00に限らず動いていて、\n\t\t\t\tブロックの状態がCdumpのものを\n\t\t\t\t小さいアドレスから順に探して書き込みます。\n\t\t\t\tその処理はdumpblock関数あたり。</p>\n\t\t\t\t<p>全部処理が終われば、cw-&gt;nodump = 1として停止。\n\t\t\t\t次にdumpキューへ入れられればまたnodump = 0となり\n\t\t\t\tプロセスが活性化します。</p>\n\t\t\t</section>\n\t\t</section>\n\t\t<section>\n\t\t\t<h2>メモ</h2>\n\t\t\t<section>\n\t\t\t\t<h3>SCSIドライバのロード</h3>\n\t\t\t\t<p>pc/scsi.cに、名前と関数(reset)を登録するテーブルがある。\n\t\t\t\tこれをpc/scsi.c:scsiinitから調べて、\n\t\t\t\t一致すれば関数の戻り値をコントローラ構造体のioに入れる。\n\t\t\t\t関数(reset)は、scsiの入出力を処理する関数(Scsiio)を\n\t\t\t\t返すようになっているので、\n\t\t\t\tデバイスドライバ依存の処理は全部これを通して扱うみたい。\n\t\t\t\tちなみに同名の関数がいくつかあるけど、#ifdef FSのものが有効。</p>\n\t\t\t</section>\n\t\t</section>\n\t</section>\n</main>\n<aside>\n\t<section>\n\t\t<h1>関連ページ</h1>\n\t\t<ul>\n\t\t<li><a href=\"04282.html\">ファイルサーバのディスクレイアウト</a></li>\n\t\t<li><a href=\"../2010/0705.html\">fsバックアップメモ</a></li>\n\t\t</ul>\n\t</section>\n\t<section>\n\t\t<h1>参考サイト</h1>\n\t\t<ul>\n\t\t<li><a href=\"http://plan9.aichi-u.ac.jp/cwfs/\">cwfsの研究</a></li>\n\t\t</ul>\n\t</section>\n</aside>\n<aside>\n\t<h1>やっていること</h1>\n\t<ul>\n\t<li><a href=\"/plan9/index.html\">Plan 9</a></li>\n\t<li><a href=\"http://web.me.com/lufia/alefcompiler/alef/\">Alefコンパイラを読む</a></li>\n\t</ul>\n</aside>\n<footer>\n\t<p>見れない、表示がおかしい場合は、動作環境を添えて<a href=\"mailto:webmaster@lufia.org\">webmaster@lufia.org</a>まで連絡ください。</p>\n</footer>\n</body>\n</html>\n"},"__N_SSG":true}