---
Title: Go & Versioning(vgo)を読んで大きな変更が入ったなと思った
Category:
- Go
- Exported from Qiita
Date: 2018-02-23T02:16:00+09:00
URL: https://blog.lufia.org/entry/2018/02/23/021600
EditURL: https://blog.hatena.ne.jp/lufiabb/lufia.hateblo.jp/atom/entry/26006613541709309
---

**この記事はQiitaで公開されていました**

このQiita記事は、[Go & Versioning](https://research.swtch.com/vgo)で掲載された一連の記事を読んで、自分なりのまとめと感想です。私の周りはあまり騒いでないけど、これ感覚的なものが大きく変わるなあ、と思ったので、主に表面上に現れる変更をまとめました。

これは、Go 1.11で試験的な導入、Go 1.12で正式サポートとなる予定の機能に関する話です。

@nekketsuuuさんが原文の和訳をされています。

* [和訳: Go & Versioning](https://qiita.com/nekketsuuu/items/36f00484ff7c30fd2007)

## 何が変わるのか

### バージョン管理機能の導入

`go`コマンドにバージョン管理の機能が追加されます。バージョンは常に[セマンティックバージョニング](https://semver.org/lang/ja/)で表します。今も`dep`コマンドが(`go`とは別に)存在しますが、バージョン管理機能が追加された`go`コマンド(以下`vgo`と表記)は、`dep`や`glide`などの依存管理ツールとは別のアプローチでバージョンを管理します。とはいえ、目的はどちらもバージョン管理なので、`vgo`を使う場合は`dep`を使いません。また、`vgo`は*vendor*ディレクトリを使わないため*vendor*も不要です。

### モジュールという単位の追加

バージョン管理機能に伴って、Goのパッケージに**モジュール**という単位が追加されます。モジュールは複数のパッケージをまとめたもので、*go.mod*というファイルで管理します。[Go &amp; Versioning](https://research.swtch.com/vgo)では以下の例が記されていました。

```go:go.mod
// My hello, world

module "rsc.io/hello"

require (
	"golang.org/x/text" v0.0.0-20180208041248-4e4a3210bb54
	"rsc.io/quote" v1.5.2
)
```

モジュールは、`vgo`でバージョン管理を行う基本的な単位となります。1つのリポジトリが1つのモジュールに該当し、タグ(`git tag`)を使ってモジュールにバージョンを与えます。従って、バージョン管理を行う単位はモジュールです。例えば、上の*go.mod*でリストされている`golang.org/x/text`と`rsc.io/quote`もモジュールです。今まではパッケージという扱いでしたが、モジュールに変わります。

### モジュールのアップデートは`vgo get`

モジュールは*go.mod*ファイルでバージョンを指定しますが、これを人が維持するのは大変です。`vgo get`で必要なモジュールを追加したり、`vgo get -u`でアップデートを行ったりするようです。

たくさんのExampleが書かれているので[A Tour of Versioned Go](https://research.swtch.com/vgo-tour)を眺めてみてください。これだけで雰囲気はつかめると思います。

### 破壊的変更を加える場合はimport pathを変更する

`vgo`で扱うパッケージは、全て後方互換性を持たなければなりません。例えば`A`というパッケージの作者は、メジャーバージョンが同じ間は後方互換性を維持する必要があります。この制約によって、*v1.1.0*を参照しているプログラムは、*v1.2.1*が使われた場合でも同じように動作することが保証されます。もしマイナーバージョンのアップデートでビルドが壊れた場合、`A`は*v1.2.2*で過去の互換性を取り戻すべきです。例えば、関数の動作を変更する場合は、仕様変更ではなく名前を変えて新しい関数として追加しましょう。

とはいえ、どうしても破壊的な変更が避けられないケースは存在します。その場合は**import pathを変更する**ことで別のパッケージとして作成してください。例えば、`lufia.org/pkg/x`に破壊的変更を加える場合、新しいバージョンは`lufia.org/pkg/x/v2`のようにメジャーバージョンを含むimport pathにしましょう。そうすると`v1`と`v2`で重複する部分がソースコードの二重管理になりがちですが、それは`typealias`等を使って頑張ってください。

* [go言語1.9で追加予定の新機能 型エイリアス](https://qiita.com/weloan/items/8abbb4003cfa1031a9e9)

最初からimport pathを`lufia.org/pkg/x/v1`のようにするべきかについては、最終的にどうなるかは分かりませんが、個人的には「最初はバージョンを含めない」でいいと思います。

### *$GOPATH*が不要になる

これまで*$GOPATH*はGoワークスペースのルートとして必要でしたが、`vgo`では*go.mod*によってモジュールのURLやバージョンが明確に特定できるため、*$GOPATH*がなくてもソースコードの取得やビルドの再現性には困りません。参照するモジュールのマイナーバージョンは上がるかもしれませんが、マイナーバージョンの変更はモジュール作者の努力によって互換性が維持されるため、最終的な動作は変わらないことが保証できます。

これによって、任意のディレクトリでGoのコードを書くことが可能となります。今までのように、*$GOPATH*配下にワークスペースを構築する必要は無くなります。

ただこれ疑問なのは、今までの*$GOPATH*直下には

```console
$ ls $GOPATH
bin	pkg	src
```

が存在していて、まあ*src*と*pkg*は無くてもいいかなと思うのですが、`go get`でインストールする場所としての*$GOPATH*はどうなるんだろう？と思いました。

## 何が変わらないのか

### 今までのコードはそのままビルド可能

`vgo`だからといって今までのコードが壊れることはありません。*$GOPATH*も*vendor*も、不要になるだけで、そのまま使えます。*go.mod*がないリポジトリもそのままビルドできるはずです。

### `dep`は`vgo`が普及するまでは残る

長期的にみれば`dep`は無くなるのかもしれませんが、少なくとも`vgo`がリリースされて、十分に普及するまでは継続することが書かれていました。今すぐ何かが変わることはないので、そのまま使い続けても問題ないと思います。

## 今後の話

`vgo`は、この記事の最初にも書きましたけれど、Go 1.11で試験的な導入、Go 1.12で正式サポートとなる予定です。今はまだGo 1.10がリリースされたばかりなので何もしなくても良いと思いますが、半年後にGo 1.11がリリースされたら、特にパッケージ作者は以下のことに注意しましょう。

* *go.mod*を作成しましょう
* セマンティックバージョニングでタグを打ちましょう
* import pathが同一である限り後方互換性を維持しましょう

